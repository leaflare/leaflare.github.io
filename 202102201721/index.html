<!DOCTYPE html>
<html lang="en">
    <head>
      <meta http-equiv="X-UA-Compatible" content="IE=edge">
      <meta http-equiv="content-type" content="text/html; charset=utf-8">

      <!-- Enable responsiveness on mobile devices-->
      <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">

      <title>Arceus - Basic template</title>

      

      
          <script src="https://cdnjs.cloudflare.com/ajax/libs/slideout/1.0.1/slideout.min.js"></script>
          
      

      
          <link rel="stylesheet" href="https://arceusj2000.github.io/site.css">
          
      

      
      
    </head>

    <body>
        <div class="container">

            <div id="mobile-navbar" class="mobile-navbar">
              <div class="mobile-header-logo">
                <a href="/" class="logo">Arceus</a>
              </div>
              <div class="mobile-navbar-icon icon-out">
                <span></span>
                <span></span>
                <span></span>
              </div>
            </div>

            <nav id="mobile-menu" class="mobile-menu slideout-menu slideout-menu-left">
              <ul class="mobile-menu-list">
                
                    <li class="mobile-menu-item">
                        <a href="https:&#x2F;&#x2F;arceusj2000.github.io">
                            主页
                        </a>
                    </li>
                
                    <li class="mobile-menu-item">
                        <a href="https:&#x2F;&#x2F;arceusj2000.github.io&#x2F;categories">
                            分类
                        </a>
                    </li>
                
                    <li class="mobile-menu-item">
                        <a href="https:&#x2F;&#x2F;arceusj2000.github.io&#x2F;tags">
                            标签
                        </a>
                    </li>
                
                    <li class="mobile-menu-item">
                        <a href="https:&#x2F;&#x2F;github.com&#x2F;arceusj2000">
                            GitHub
                        </a>
                    </li>
                
              </ul>
            </nav>

            <header id="header">
                <div class="logo"><a href="https:&#x2F;&#x2F;arceusj2000.github.io">Arceus</a></div>
                <nav class="menu">
                    <ul>
                        
                            <li>
                                <a href="https:&#x2F;&#x2F;arceusj2000.github.io">
                                    主页
                                </a>
                            </li>
                        
                            <li>
                                <a href="https:&#x2F;&#x2F;arceusj2000.github.io&#x2F;categories">
                                    分类
                                </a>
                            </li>
                        
                            <li>
                                <a href="https:&#x2F;&#x2F;arceusj2000.github.io&#x2F;tags">
                                    标签
                                </a>
                            </li>
                        
                            <li>
                                <a href="https:&#x2F;&#x2F;github.com&#x2F;arceusj2000">
                                    GitHub
                                </a>
                            </li>
                        
                    </ul>
                </nav>
            </header>

            <main>
                <div class="content" id="mobile-panel">
                    


<div class="post-toc" id="post-toc">
    <h2 class="post-toc-title">Contents</h2>
    <div class="post-toc-content always-active">
        <nav id="TableOfContents">
            <ul>
                
                <li>
                    <a href="https://arceusj2000.github.io/202102201721/#suan-fa" class="toc-link">算法</a>
                    
                    <ul>
                        
                        <li>
                            <a href="https://arceusj2000.github.io/202102201721/#er-fen" class="toc-link">二分</a>
                        </li>
                        
                        <li>
                            <a href="https://arceusj2000.github.io/202102201721/#gui-bing" class="toc-link">归并</a>
                        </li>
                        
                        <li>
                            <a href="https://arceusj2000.github.io/202102201721/#hua-dong-chuang-kou" class="toc-link">滑动窗口</a>
                        </li>
                        
                        <li>
                            <a href="https://arceusj2000.github.io/202102201721/#hui-su" class="toc-link">回溯</a>
                        </li>
                        
                        <li>
                            <a href="https://arceusj2000.github.io/202102201721/#qian-zhui-he" class="toc-link">前缀和</a>
                        </li>
                        
                    </ul>
                    
                </li>
                
            </ul>
        </nav>
    </div>
</div>


<article class="post">
    
    <header class="post__header">
        <h1 class="post__title">
            <a href="https:&#x2F;&#x2F;arceusj2000.github.io&#x2F;202102201721&#x2F;">Basic template</a>
        </h1>
        <div class="post__meta">
            <span class="post__time">2021-02-20</span>
            
        </div>
    </header>

    <div class="post-content">
      <span id="continue-reading"></span><h1 id="suan-fa">算法</h1>
<h2 id="er-fen">二分</h2>
<pre data-lang="c++" style="background-color:#2b303b;color:#c0c5ce;" class="language-c++ "><code class="language-c++" data-lang="c++"><span style="color:#b48ead;">int</span><span> l = </span><span style="color:#d08770;">0</span><span>, r = MAXN - </span><span style="color:#d08770;">1</span><span>;
</span><span style="color:#b48ead;">while </span><span>(l &lt; r) {
</span><span>	</span><span style="color:#b48ead;">int</span><span> mid = l + r &gt;&gt; </span><span style="color:#d08770;">1</span><span>;
</span><span>	</span><span style="color:#b48ead;">if </span><span>(</span><span style="color:#bf616a;">check</span><span>(mid))
</span><span>		r = mid;
</span><span>	</span><span style="color:#b48ead;">else
</span><span>        l = mid + </span><span style="color:#d08770;">1</span><span>;
</span><span>}
</span><span style="color:#b48ead;">return</span><span> left;
</span></code></pre>
<h3 id="sou-suo-qu-jian"><strong>搜索区间</strong></h3>
<p>两端都闭 <code>[left, right]</code> 和左闭右开 <code>[left, right)</code> 的区别</p>
<ul>
<li>两端都闭 [2, 3] 会搜索 2,3 [2, 2] 会搜索 2 [3, 2] 时无效跳出循环</li>
<li>左闭右开 [2, 3) 会搜索 2 [2, 2] 时无效跳出循环</li>
<li>如果排序数组中是无重复元素的，果断用「寻找一个数」的左闭右闭模版</li>
</ul>
<p>两端都闭 <code>[left, right]</code> 搜索区间设置方法：</p>
<pre style="background-color:#2b303b;color:#c0c5ce;"><code><span>int left = 0;
</span><span>int right = nums.size() - 1;
</span><span>while (left &lt;= right) {return mid;}
</span></code></pre>
<p>左闭右开 <code>[left, right)</code> 搜索区间设置方法：</p>
<pre style="background-color:#2b303b;color:#c0c5ce;"><code><span>int left = 0;
</span><span>int right = nums.size();
</span><span>while (left &lt; right) {}
</span><span>return left;
</span></code></pre>
<h3 id="lower-he-upper-bound">lower 和 upper bound</h3>
<p>例题：<a href="https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/">在排序数组中查找元素的第一个和最后一个位置</a></p>
<pre data-lang="c++" style="background-color:#2b303b;color:#c0c5ce;" class="language-c++ "><code class="language-c++" data-lang="c++"><span style="color:#b48ead;">class </span><span style="color:#ebcb8b;">Solution </span><span style="color:#eff1f5;">{
</span><span style="color:#b48ead;">public</span><span style="color:#eff1f5;">:
</span><span style="color:#eff1f5;">    vector&lt;</span><span style="color:#b48ead;">int</span><span style="color:#eff1f5;">&gt; </span><span style="color:#8fa1b3;">searchRange</span><span style="color:#eff1f5;">(vector&lt;</span><span style="color:#b48ead;">int</span><span style="color:#eff1f5;">&gt;</span><span>&amp; </span><span style="color:#bf616a;">nums</span><span style="color:#eff1f5;">, </span><span style="color:#b48ead;">int </span><span style="color:#bf616a;">target</span><span style="color:#eff1f5;">) {
</span><span style="color:#eff1f5;">        </span><span style="color:#b48ead;">if</span><span style="color:#eff1f5;">(nums.</span><span style="color:#bf616a;">empty</span><span style="color:#eff1f5;">()) </span><span style="color:#b48ead;">return </span><span style="color:#eff1f5;">{</span><span>-</span><span style="color:#d08770;">1</span><span style="color:#eff1f5;">,</span><span>-</span><span style="color:#d08770;">1</span><span style="color:#eff1f5;">};
</span><span style="color:#eff1f5;">    
</span><span style="color:#eff1f5;">        </span><span style="color:#b48ead;">int</span><span style="color:#eff1f5;"> l </span><span>= </span><span style="color:#d08770;">0</span><span style="color:#eff1f5;">, r </span><span>=</span><span style="color:#eff1f5;"> nums.</span><span style="color:#bf616a;">size</span><span style="color:#eff1f5;">() </span><span>- </span><span style="color:#d08770;">1</span><span style="color:#eff1f5;">; </span><span style="color:#65737e;">//二分范围
</span><span style="color:#eff1f5;">        </span><span style="color:#b48ead;">while</span><span style="color:#eff1f5;">( l </span><span>&lt;</span><span style="color:#eff1f5;"> r)			        </span><span style="color:#65737e;">//查找元素的开始位置
</span><span style="color:#eff1f5;">        {
</span><span style="color:#eff1f5;">            </span><span style="color:#b48ead;">int</span><span style="color:#eff1f5;"> mid </span><span>= </span><span style="color:#eff1f5;">(l </span><span>+</span><span style="color:#eff1f5;"> r )</span><span>/</span><span style="color:#d08770;">2</span><span style="color:#eff1f5;">;
</span><span style="color:#eff1f5;">            </span><span style="color:#b48ead;">if</span><span style="color:#eff1f5;">(nums[mid] </span><span>&gt;=</span><span style="color:#eff1f5;"> target) r </span><span>=</span><span style="color:#eff1f5;"> mid;
</span><span style="color:#eff1f5;">            </span><span style="color:#b48ead;">else</span><span style="color:#eff1f5;"> l </span><span>=</span><span style="color:#eff1f5;"> mid </span><span>+ </span><span style="color:#d08770;">1</span><span style="color:#eff1f5;">;
</span><span style="color:#eff1f5;">        }
</span><span style="color:#eff1f5;">        </span><span style="color:#b48ead;">if</span><span style="color:#eff1f5;">( nums[r] </span><span>!=</span><span style="color:#eff1f5;"> target) </span><span style="color:#b48ead;">return </span><span style="color:#eff1f5;">{</span><span>-</span><span style="color:#d08770;">1</span><span style="color:#eff1f5;">,</span><span>-</span><span style="color:#d08770;">1</span><span style="color:#eff1f5;">};  </span><span style="color:#65737e;">//查找失败
</span><span style="color:#eff1f5;">        </span><span style="color:#b48ead;">int</span><span style="color:#eff1f5;"> L </span><span>=</span><span style="color:#eff1f5;"> r;
</span><span style="color:#eff1f5;">        l </span><span>= </span><span style="color:#d08770;">0</span><span style="color:#eff1f5;">, r </span><span>=</span><span style="color:#eff1f5;"> nums.</span><span style="color:#bf616a;">size</span><span style="color:#eff1f5;">() </span><span>- </span><span style="color:#d08770;">1</span><span style="color:#eff1f5;">;     </span><span style="color:#65737e;">//二分范围
</span><span style="color:#eff1f5;">        </span><span style="color:#b48ead;">while</span><span style="color:#eff1f5;">( l </span><span>&lt;</span><span style="color:#eff1f5;"> r)                   </span><span style="color:#65737e;">//查找元素的结束位置
</span><span style="color:#eff1f5;">        {
</span><span style="color:#eff1f5;">            </span><span style="color:#b48ead;">int</span><span style="color:#eff1f5;"> mid </span><span>= </span><span style="color:#eff1f5;">(l </span><span>+</span><span style="color:#eff1f5;"> r </span><span>+ </span><span style="color:#d08770;">1</span><span style="color:#eff1f5;">)</span><span>/</span><span style="color:#d08770;">2</span><span style="color:#eff1f5;">;
</span><span style="color:#eff1f5;">            </span><span style="color:#b48ead;">if</span><span style="color:#eff1f5;">(nums[mid] </span><span>&lt;=</span><span style="color:#eff1f5;"> target ) l </span><span>=</span><span style="color:#eff1f5;"> mid;
</span><span style="color:#eff1f5;">            </span><span style="color:#b48ead;">else</span><span style="color:#eff1f5;"> r </span><span>=</span><span style="color:#eff1f5;"> mid </span><span>- </span><span style="color:#d08770;">1</span><span style="color:#eff1f5;">;
</span><span style="color:#eff1f5;">        }
</span><span style="color:#eff1f5;">        </span><span style="color:#b48ead;">return </span><span style="color:#eff1f5;">{L,r};
</span><span style="color:#eff1f5;">    }
</span><span style="color:#eff1f5;">}</span><span>;
</span></code></pre>
<h3 id="cha-zhao-xuan-zhuan-shu-zu">查找旋转数组</h3>
<h4 id="zui-xiao-zhi"><a href="https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array-ii">最小值</a></h4>
<pre data-lang="c++" style="background-color:#2b303b;color:#c0c5ce;" class="language-c++ "><code class="language-c++" data-lang="c++"><span style="color:#b48ead;">int </span><span style="color:#8fa1b3;">findMin</span><span>(vector&lt;</span><span style="color:#b48ead;">int</span><span>&gt;&amp; </span><span style="color:#bf616a;">nums</span><span>) {
</span><span>        </span><span style="color:#b48ead;">int</span><span> left = </span><span style="color:#d08770;">0</span><span>;
</span><span>        </span><span style="color:#b48ead;">int</span><span> right = nums.</span><span style="color:#bf616a;">size</span><span>()-</span><span style="color:#d08770;">1</span><span>;
</span><span>        </span><span style="color:#b48ead;">while</span><span>(left&lt;right){
</span><span>            </span><span style="color:#b48ead;">int</span><span> mid = left + (right-left)/</span><span style="color:#d08770;">2</span><span>;
</span><span>            </span><span style="color:#b48ead;">if</span><span>(nums[mid] &gt; nums[right]){
</span><span>                left = mid+</span><span style="color:#d08770;">1</span><span>;
</span><span>            }
</span><span>            </span><span style="color:#b48ead;">else if</span><span>(nums[mid] &lt; nums[right]){
</span><span>                right = mid;
</span><span>            }
</span><span>            </span><span style="color:#b48ead;">else</span><span>{
</span><span>                right --;
</span><span>            }
</span><span>        }
</span><span>        </span><span style="color:#b48ead;">return</span><span> nums[left];
</span><span>    }
</span></code></pre>
<h4 id="yong-zui-da-zhi-qiu-zui-xiao-zhi">用最大值求最小值</h4>
<p>最大值右边就是最小值</p>
<pre data-lang="c++" style="background-color:#2b303b;color:#c0c5ce;" class="language-c++ "><code class="language-c++" data-lang="c++"><span style="color:#b48ead;">int </span><span style="color:#8fa1b3;">findMin</span><span>(vector&lt;</span><span style="color:#b48ead;">int</span><span>&gt;&amp; </span><span style="color:#bf616a;">nums</span><span>) {
</span><span>        </span><span style="color:#b48ead;">int</span><span> left = </span><span style="color:#d08770;">0</span><span>;
</span><span>        </span><span style="color:#b48ead;">int</span><span> right = nums.</span><span style="color:#bf616a;">size</span><span>() - </span><span style="color:#d08770;">1</span><span>;
</span><span>        </span><span style="color:#b48ead;">while </span><span>(left &lt; right) {
</span><span>            </span><span style="color:#b48ead;">int</span><span> mid = left + (right - left + </span><span style="color:#d08770;">1</span><span>) / </span><span style="color:#d08770;">2</span><span>;   </span><span style="color:#65737e;">/* 先加一再除，mid更靠近右边的right */
</span><span>            </span><span style="color:#b48ead;">if </span><span>(nums[left] &lt; nums[mid]) {
</span><span>                left = mid;                            </span><span style="color:#65737e;">/* 向右移动左边界 */
</span><span>            } </span><span style="color:#b48ead;">else if </span><span>(nums[left] &gt; nums[mid]) {
</span><span>                right = mid - </span><span style="color:#d08770;">1</span><span>;                       </span><span style="color:#65737e;">/* 向左移动右边界 */
</span><span>            }
</span><span>        }
</span><span>        </span><span style="color:#b48ead;">return</span><span> nums[(right + </span><span style="color:#d08770;">1</span><span>) % nums.</span><span style="color:#bf616a;">size</span><span>()];    </span><span style="color:#65737e;">/* 最大值向右移动一位就是最小值了（需要考虑最大值在最右边的情况，右移一位后对数组长度取余） */
</span><span>    }
</span></code></pre>
<h2 id="gui-bing">归并</h2>
<p><a href="https://leetcode-cn.com/problems/sort-list/">148. 排序链表 - LeetCode</a></p>
<pre data-lang="c++" style="background-color:#2b303b;color:#c0c5ce;" class="language-c++ "><code class="language-c++" data-lang="c++"><span style="color:#b48ead;">class </span><span style="color:#ebcb8b;">Solution </span><span style="color:#eff1f5;">{
</span><span style="color:#b48ead;">public</span><span style="color:#eff1f5;">:
</span><span style="color:#eff1f5;">    ListNode</span><span>* </span><span style="color:#8fa1b3;">merge</span><span style="color:#eff1f5;">(ListNode</span><span>* </span><span style="color:#bf616a;">head</span><span style="color:#eff1f5;">, ListNode</span><span>* </span><span style="color:#bf616a;">head2</span><span style="color:#eff1f5;">){
</span><span style="color:#eff1f5;">        </span><span style="color:#b48ead;">if</span><span style="color:#eff1f5;">(head</span><span>==</span><span style="color:#d08770;">nullptr</span><span style="color:#eff1f5;">) </span><span style="color:#b48ead;">return</span><span style="color:#eff1f5;"> head2;
</span><span style="color:#eff1f5;">        </span><span style="color:#b48ead;">if</span><span style="color:#eff1f5;">(head2</span><span>==</span><span style="color:#d08770;">nullptr</span><span style="color:#eff1f5;">) </span><span style="color:#b48ead;">return</span><span style="color:#eff1f5;"> head;
</span><span style="color:#eff1f5;">        </span><span style="color:#b48ead;">if</span><span style="color:#eff1f5;">(head-&gt;</span><span style="color:#bf616a;">val </span><span>&lt;=</span><span style="color:#eff1f5;"> head2-&gt;</span><span style="color:#bf616a;">val</span><span style="color:#eff1f5;">){
</span><span style="color:#eff1f5;">            head-&gt;</span><span style="color:#bf616a;">next </span><span>= </span><span style="color:#bf616a;">merge</span><span style="color:#eff1f5;">(head-&gt;</span><span style="color:#bf616a;">next</span><span style="color:#eff1f5;">, head2);
</span><span style="color:#eff1f5;">            </span><span style="color:#b48ead;">return</span><span style="color:#eff1f5;"> head;
</span><span style="color:#eff1f5;">        }
</span><span style="color:#eff1f5;">        </span><span style="color:#b48ead;">else</span><span style="color:#eff1f5;">{
</span><span style="color:#eff1f5;">            head2-&gt;</span><span style="color:#bf616a;">next </span><span>= </span><span style="color:#bf616a;">merge</span><span style="color:#eff1f5;">(head, head2-&gt;</span><span style="color:#bf616a;">next</span><span style="color:#eff1f5;">);
</span><span style="color:#eff1f5;">            </span><span style="color:#b48ead;">return</span><span style="color:#eff1f5;"> head2;
</span><span style="color:#eff1f5;">        }
</span><span style="color:#eff1f5;">    }
</span><span style="color:#eff1f5;">    ListNode</span><span>* </span><span style="color:#8fa1b3;">sortList</span><span style="color:#eff1f5;">(ListNode</span><span>* </span><span style="color:#bf616a;">head</span><span style="color:#eff1f5;">) {
</span><span style="color:#eff1f5;">        </span><span style="color:#b48ead;">if</span><span style="color:#eff1f5;">(head</span><span>==</span><span style="color:#d08770;">nullptr</span><span>||</span><span style="color:#eff1f5;">head-&gt;</span><span style="color:#bf616a;">next</span><span>==</span><span style="color:#d08770;">nullptr</span><span style="color:#eff1f5;">) </span><span style="color:#b48ead;">return</span><span style="color:#eff1f5;"> head;
</span><span style="color:#eff1f5;">        ListNode</span><span>*</span><span style="color:#eff1f5;"> slow</span><span>=</span><span style="color:#eff1f5;">head;
</span><span style="color:#eff1f5;">        ListNode</span><span>*</span><span style="color:#eff1f5;"> fast</span><span>=</span><span style="color:#eff1f5;">head-&gt;</span><span style="color:#bf616a;">next</span><span style="color:#eff1f5;">;
</span><span style="color:#eff1f5;">        </span><span style="color:#b48ead;">while</span><span style="color:#eff1f5;">(fast</span><span>!=</span><span style="color:#d08770;">nullptr</span><span>&amp;&amp;</span><span style="color:#eff1f5;">fast-&gt;</span><span style="color:#bf616a;">next</span><span>!=</span><span style="color:#d08770;">nullptr</span><span style="color:#eff1f5;">){
</span><span style="color:#eff1f5;">            slow</span><span>=</span><span style="color:#eff1f5;">slow-&gt;</span><span style="color:#bf616a;">next</span><span style="color:#eff1f5;">;
</span><span style="color:#eff1f5;">            fast</span><span>=</span><span style="color:#eff1f5;">fast-&gt;</span><span style="color:#bf616a;">next</span><span style="color:#eff1f5;">-&gt;</span><span style="color:#bf616a;">next</span><span style="color:#eff1f5;">;
</span><span style="color:#eff1f5;">        }
</span><span style="color:#eff1f5;">        ListNode</span><span>*</span><span style="color:#eff1f5;"> head2</span><span>=</span><span style="color:#eff1f5;">slow-&gt;</span><span style="color:#bf616a;">next</span><span style="color:#eff1f5;">;
</span><span style="color:#eff1f5;">        slow-&gt;</span><span style="color:#bf616a;">next</span><span>=</span><span style="color:#d08770;">nullptr</span><span style="color:#eff1f5;">;
</span><span style="color:#eff1f5;">        </span><span style="color:#b48ead;">return </span><span style="color:#bf616a;">merge</span><span style="color:#eff1f5;">(</span><span style="color:#bf616a;">sortList</span><span style="color:#eff1f5;">(head),</span><span style="color:#bf616a;">sortList</span><span style="color:#eff1f5;">(head2));
</span><span style="color:#eff1f5;">    }
</span><span style="color:#eff1f5;">}</span><span>;
</span></code></pre>
<h3 id="gui-bing-pai-xu-mo-ban">归并排序模板</h3>
<pre data-lang="java" style="background-color:#2b303b;color:#c0c5ce;" class="language-java "><code class="language-java" data-lang="java"><span>    </span><span style="color:#65737e;">//归并排序入口
</span><span>    </span><span style="color:#b48ead;">public</span><span> void </span><span style="color:#bf616a;">mergeSort</span><span>(</span><span style="color:#b48ead;">int[]</span><span> nums){
</span><span>        </span><span style="color:#bf616a;">MergeSort</span><span>(nums,</span><span style="color:#d08770;">0</span><span>,nums.length-</span><span style="color:#d08770;">1</span><span>);
</span><span>    }
</span><span>
</span><span>    </span><span style="color:#65737e;">/**
</span><span style="color:#65737e;">     * 归并排序
</span><span style="color:#65737e;">     * </span><span style="color:#b48ead;">@param </span><span style="color:#bf616a;">nums</span><span style="color:#65737e;"> 待排序数组
</span><span style="color:#65737e;">     * </span><span style="color:#b48ead;">@param </span><span style="color:#bf616a;">start</span><span style="color:#65737e;"> 数组开始的下标
</span><span style="color:#65737e;">     * </span><span style="color:#b48ead;">@param </span><span style="color:#bf616a;">end</span><span style="color:#65737e;"> 数组结束的下标
</span><span style="color:#65737e;">     */
</span><span style="color:#65737e;">    private void MergeSort(int[] nums,int start,int end){
</span><span style="color:#65737e;">        if(start&lt;</span><span style="color:#bf616a;">end){
</span><span style="color:#65737e;">            </span><span style="color:#d08770;">int mid</span><span style="color:#65737e;">=</span><span style="color:#a3be8c;">start+(end-start)/2;
</span><span style="color:#65737e;">            </span><span style="color:#d08770;">MergeSort(nums,start,mid); </span><span style="color:#65737e;">//</span><span style="color:#d08770;">将无序数组划分
</span><span style="color:#65737e;">            </span><span style="color:#d08770;">MergeSort(nums,mid+1,end); </span><span style="color:#65737e;">//</span><span style="color:#d08770;">将无序数组划分
</span><span style="color:#65737e;">            </span><span style="color:#d08770;">merge(nums,start,mid,end); </span><span style="color:#65737e;">//</span><span style="color:#d08770;">再将两个有序数组合并
</span><span style="color:#65737e;">        </span><span style="color:#d08770;">}
</span><span style="color:#65737e;">    </span><span style="color:#d08770;">}
</span><span style="color:#65737e;">
</span><span style="color:#65737e;">    /</span><span style="color:#d08770;">**
</span><span style="color:#65737e;">     </span><span style="color:#d08770;">*  双指针合并两个有序数组
</span><span style="color:#65737e;">     * </span><span style="color:#b48ead;">@param </span><span style="color:#bf616a;">nums
</span><span style="color:#65737e;">     * </span><span style="color:#b48ead;">@param </span><span style="color:#bf616a;">start
</span><span style="color:#65737e;">     * </span><span style="color:#b48ead;">@param </span><span style="color:#bf616a;">mid
</span><span style="color:#65737e;">     * </span><span style="color:#b48ead;">@param </span><span style="color:#bf616a;">end
</span><span style="color:#65737e;">     */
</span><span style="color:#65737e;">    private void merge(int[]nums, int start, int mid, int end){
</span><span style="color:#65737e;">        int P1=start;
</span><span style="color:#65737e;">        int P2=mid+1;
</span><span style="color:#65737e;">        int tmp[]=new int[end-start+1]; //需要借助额外的O(n)空间来存储合并后的数组
</span><span style="color:#65737e;">        int cur=0;
</span><span style="color:#65737e;">        while (P1&lt;=mid&amp;&amp;P2&lt;=end){
</span><span style="color:#65737e;">            if(nums[P1]&lt;</span><span style="color:#bf616a;">nums[P2]){
</span><span style="color:#65737e;">               </span><span style="color:#d08770;">tmp[cur]</span><span style="color:#65737e;">=</span><span style="color:#a3be8c;">nums[P1];
</span><span style="color:#65737e;">               </span><span style="color:#d08770;">P1++;
</span><span style="color:#65737e;">            </span><span style="color:#d08770;">}else {
</span><span style="color:#65737e;">               </span><span style="color:#d08770;">tmp[cur]</span><span style="color:#65737e;">=</span><span style="color:#a3be8c;">nums[P2];
</span><span style="color:#65737e;">               </span><span style="color:#d08770;">P2++;
</span><span style="color:#65737e;">            </span><span style="color:#d08770;">}
</span><span style="color:#65737e;">            </span><span style="color:#d08770;">cur++;
</span><span style="color:#65737e;">        </span><span style="color:#d08770;">}
</span><span style="color:#65737e;">        </span><span style="color:#d08770;">while (P1</span><span style="background-color:#bf616a;color:#2b303b;">&lt;</span><span style="color:#65737e;">=</span><span style="color:#a3be8c;">mid){
</span><span style="color:#65737e;">            </span><span style="color:#d08770;">tmp[cur]</span><span style="color:#65737e;">=</span><span style="color:#a3be8c;">nums[P1];
</span><span style="color:#65737e;">            </span><span style="color:#d08770;">P1++;
</span><span style="color:#65737e;">            </span><span style="color:#d08770;">cur++;
</span><span style="color:#65737e;">        </span><span style="color:#d08770;">}
</span><span style="color:#65737e;">        </span><span style="color:#d08770;">while (P2</span><span style="background-color:#bf616a;color:#2b303b;">&lt;</span><span style="color:#65737e;">=</span><span style="color:#a3be8c;">end){
</span><span style="color:#65737e;">            </span><span style="color:#d08770;">tmp[cur]</span><span style="color:#65737e;">=</span><span style="color:#a3be8c;">nums[P2];
</span><span style="color:#65737e;">            </span><span style="color:#d08770;">P2++;
</span><span style="color:#65737e;">            </span><span style="color:#d08770;">cur++;
</span><span style="color:#65737e;">        </span><span style="color:#d08770;">}
</span><span style="color:#65737e;">        </span><span style="color:#d08770;">for (int i </span><span style="color:#65737e;">= </span><span style="color:#a3be8c;">0; </span><span style="color:#d08770;">i </span><span style="background-color:#bf616a;color:#2b303b;">&lt;</span><span style="color:#65737e;"> </span><span style="color:#d08770;">res.length ; i++) {
</span><span style="color:#65737e;">             </span><span style="color:#d08770;">nums[i+start]</span><span style="color:#65737e;">=</span><span style="color:#a3be8c;">tmp[i];
</span><span style="color:#65737e;">        </span><span style="color:#d08770;">}
</span><span style="color:#65737e;">    </span><span style="color:#d08770;">}
</span></code></pre>
<h2 id="hua-dong-chuang-kou">滑动窗口</h2>
<pre data-lang="c++" style="background-color:#2b303b;color:#c0c5ce;" class="language-c++ "><code class="language-c++" data-lang="c++"><span style="color:#b48ead;">void </span><span style="color:#8fa1b3;">slidingWindow</span><span>(string </span><span style="color:#bf616a;">s</span><span>, string </span><span style="color:#bf616a;">t</span><span>) {
</span><span>    </span><span style="color:#b48ead;">int</span><span> left = </span><span style="color:#d08770;">0</span><span>;
</span><span>    </span><span style="color:#b48ead;">int</span><span> right = </span><span style="color:#d08770;">0</span><span>;
</span><span>    </span><span style="color:#b48ead;">int</span><span> valid = </span><span style="color:#d08770;">0</span><span>; </span><span style="color:#65737e;">// 窗口内已凑齐的字符种类数量
</span><span>    unordered_map&lt;</span><span style="color:#b48ead;">char</span><span>, </span><span style="color:#b48ead;">int</span><span>&gt; window;
</span><span>    unordered_map&lt;</span><span style="color:#b48ead;">char</span><span>, </span><span style="color:#b48ead;">int</span><span>&gt; need; </span><span style="color:#65737e;">// 需要凑齐的字符和对应数量
</span><span>    </span><span style="color:#b48ead;">for </span><span>(</span><span style="color:#b48ead;">char</span><span> c : t) need[c]++;
</span><span>
</span><span>    </span><span style="color:#b48ead;">while </span><span>(right &lt; s.</span><span style="color:#bf616a;">size</span><span>()) {
</span><span>        </span><span style="color:#65737e;">// 右边届入窗口，进行窗口内数据的一系列更新
</span><span>        window[s[right]]++;
</span><span>        </span><span style="color:#b48ead;">if </span><span>(window[s[right]] == need[s[right]]) {
</span><span>            valid++;
</span><span>        }  </span><span style="color:#65737e;">// 注意：先加，再判断
</span><span>
</span><span>        </span><span style="color:#65737e;">// 判断左侧窗口是否要收缩
</span><span>        </span><span style="color:#b48ead;">while </span><span>(window needs shrink) {
</span><span>            </span><span style="color:#65737e;">// 左边界移出窗口，进行窗口内数据的一系列更新
</span><span>            </span><span style="color:#b48ead;">if </span><span>(window[s[left]] == need[s[left]]) {
</span><span>                valid--;
</span><span>            }  </span><span style="color:#65737e;">// 注意：先判断，再减
</span><span>            window[s[left]]--;
</span><span>            left++;  </span><span style="color:#65737e;">// 注意：左边届的收缩，要写在所有处理完成的最后
</span><span>        }
</span><span>        </span><span style="color:#65737e;">// 采集答案...
</span><span>        right++;  </span><span style="color:#65737e;">// 注意：右边届的收缩，要写在所有处理完成的最后
</span><span>    }
</span><span>}
</span></code></pre>
<h2 id="hui-su">回溯</h2>
<pre style="background-color:#2b303b;color:#c0c5ce;"><code><span>result = []
</span><span>def backtrack(路径, 选择列表):
</span><span>    if 满足结束条件:
</span><span>        result.add(路径)
</span><span>        return
</span><span>    for 选择 in 选择列表:
</span><span>        做选择
</span><span>        backtrack(路径, 选择列表)
</span><span>        撤销选择
</span></code></pre>
<h3 id="hui-su-suan-fa-ji-chong-wen-ti-de-fu-za-du-fen-xi">回溯算法几种问题的复杂度分析</h3>
<h4 id="zi-ji-wen-ti-fen-xi">子集问题分析：</h4>
<p><strong>时间复杂度</strong>： <img src="https://www.zhihu.com/equation?tex=O%28n%5Ctimes2%5En%29" alt="[公式]" /> 。因为每一个元素的状态无外乎取与不取，一共<img src="https://www.zhihu.com/equation?tex=2%5En" alt="[公式]" /> 种状态，每种状态都需要 <img src="https://www.zhihu.com/equation?tex=O%28n%29" alt="[公式]" /> 的构造时间，最终时间复杂度为 <img src="https://www.zhihu.com/equation?tex=O%28n%5Ctimes2%5En%29" alt="[公式]" /> 。</p>
<p><strong>空间复杂度</strong>： <img src="https://www.zhihu.com/equation?tex=O%28n%29" alt="[公式]" /> ，递归深度为n，所以系统栈所用空间为 <img src="https://www.zhihu.com/equation?tex=O%28n%29" alt="[公式]" /> 。</p>
<h4 id="pai-lie-wen-ti-fen-xi">排列问题分析：</h4>
<p><strong>时间复杂度：</strong>： <img src="https://www.zhihu.com/equation?tex=O%28n%5Ctimes+n%21%29" alt="[公式]" /> 。因为一共<img src="https://www.zhihu.com/equation?tex=n%21" alt="[公式]" /> 种排列，每种排列都需要 <img src="https://www.zhihu.com/equation?tex=O%28n%29" alt="[公式]" /> 的构造时间，最终时间复杂度为 <img src="https://www.zhihu.com/equation?tex=O%28n%5Ctimes+n%21%29" alt="[公式]" /> 。</p>
<p><strong>空间复杂度</strong>： <img src="https://www.zhihu.com/equation?tex=O%28n%29" alt="[公式]" /> ，递归深度为n，所以系统栈所用空间为 <img src="https://www.zhihu.com/equation?tex=O%28n%29" alt="[公式]" /> 。</p>
<h4 id="zu-he-wen-ti-fen-xi">组合问题分析：</h4>
<p><strong>时间复杂度：</strong> <img src="https://www.zhihu.com/equation?tex=O%28C_n%5Ek+%5Ctimes+k%29" alt="[公式]" /> ，总共有 <img src="https://www.zhihu.com/equation?tex=C_n%5Ek" alt="[公式]" /> 种组合，每种组合需要 <img src="https://www.zhihu.com/equation?tex=O%28k%29" alt="[公式]" /> 的时间复杂度。另一方面，组合问题其实就是一种子集的问题，所以组合问题最坏的情况，也不会超过子集问题的时间复杂度 <img src="https://www.zhihu.com/equation?tex=O%28n%5Ctimes+2%5En%29" alt="[公式]" /> 。</p>
<p><strong>空间复杂度</strong>： <img src="https://www.zhihu.com/equation?tex=O%28n%29" alt="[公式]" /> ，递归深度为n，所以系统栈所用空间为 <img src="https://www.zhihu.com/equation?tex=O%28n%29" alt="[公式]" /> 。</p>
<h4 id="nhuang-hou-wen-ti-fen-xi">N皇后问题分析</h4>
<p><strong>时间复杂度：</strong> <img src="https://www.zhihu.com/equation?tex=O%28N%21%29" alt="[公式]" /> ，其中 N 是皇后数量，由于每个皇后必须位于不同列，因此已经放置的皇后所在的列不能放置别的皇后。第一个皇后有 N 列可以选择，第二个皇后最多有 N-1列可以选择...。</p>
<p><strong>空间复杂度</strong>： <img src="https://www.zhihu.com/equation?tex=O%28N%29" alt="[公式]" /> ，递归深度为n，所以系统栈所用空间为 <img src="https://www.zhihu.com/equation?tex=O%28N%29" alt="[公式]" /> 。</p>
<h4 id="jie-shu-du-wen-ti-fen-xi">解数独问题分析</h4>
<p><strong>时间复杂度：</strong> <img src="https://www.zhihu.com/equation?tex=O%289%5Em%29" alt="[公式]" /> ，m是'.'的数目。</p>
<p><strong>空间复杂度：</strong> <img src="https://www.zhihu.com/equation?tex=O%28n%5E2%29" alt="[公式]" /> ，n是数独盘子的大小，递归的深度是 <img src="https://www.zhihu.com/equation?tex=n%5E2" alt="[公式]" /> 。</p>
<h3 id="zi-ji">子集</h3>
<p>输入一个不包含重复数字的数组，算法输出这些数字的所有子集。</p>
<pre data-lang="c++" style="background-color:#2b303b;color:#c0c5ce;" class="language-c++ "><code class="language-c++" data-lang="c++"><span>vector&lt;vector&lt;</span><span style="color:#b48ead;">int</span><span>&gt;&gt; </span><span style="color:#8fa1b3;">subsets</span><span>(vector&lt;</span><span style="color:#b48ead;">int</span><span>&gt;&amp; </span><span style="color:#bf616a;">nums</span><span>) {
</span><span>    </span><span style="color:#65737e;">// base case，返回一个空集
</span><span>    </span><span style="color:#b48ead;">if </span><span>(nums.</span><span style="color:#bf616a;">empty</span><span>()) </span><span style="color:#b48ead;">return </span><span>{{}};
</span><span>    </span><span style="color:#65737e;">// 把最后一个元素拿出来
</span><span>    </span><span style="color:#b48ead;">int</span><span> n = nums.</span><span style="color:#bf616a;">back</span><span>();
</span><span>    nums.</span><span style="color:#bf616a;">pop_back</span><span>();
</span><span>    </span><span style="color:#65737e;">// 先递归算出前面元素的所有子集
</span><span>    vector&lt;vector&lt;</span><span style="color:#b48ead;">int</span><span>&gt;&gt; res = </span><span style="color:#bf616a;">subsets</span><span>(nums);
</span><span>
</span><span>    </span><span style="color:#b48ead;">int</span><span> size = res.</span><span style="color:#bf616a;">size</span><span>();
</span><span>    </span><span style="color:#b48ead;">for </span><span>(</span><span style="color:#b48ead;">int</span><span> i = </span><span style="color:#d08770;">0</span><span>; i &lt; size; i++) {
</span><span>        </span><span style="color:#65737e;">// 然后在之前的结果之上追加
</span><span>        res.</span><span style="color:#bf616a;">push_back</span><span>(res[i]);
</span><span>        res.</span><span style="color:#bf616a;">back</span><span>().</span><span style="color:#bf616a;">push_back</span><span>(n);
</span><span>    }
</span><span>    </span><span style="color:#b48ead;">return</span><span> res;
</span><span>}
</span></code></pre>
<p>时间复杂度：总的迭代次数应该是 2^N，因为 <code>res[i]</code> 也是一个数组，<code>push_back</code> 把 <code>res[i]</code> copy 一份然后添加到数组的最后，所以一次操作的时间是 O(N)。总的时间复杂度就是 O(N*2^N)。</p>
<p>空间复杂度，如果不计算储存返回结果所用的空间的，只需要 O(N) 的递归堆栈空间。如果计算 <code>res</code> 所需的空间，应该是 O(N*2^N)。</p>
<p><strong>第二种通用方法是回溯算法</strong></p>
<pre data-lang="c++" style="background-color:#2b303b;color:#c0c5ce;" class="language-c++ "><code class="language-c++" data-lang="c++"><span>vector&lt;vector&lt;</span><span style="color:#b48ead;">int</span><span>&gt;&gt; res;
</span><span>
</span><span>vector&lt;vector&lt;</span><span style="color:#b48ead;">int</span><span>&gt;&gt; </span><span style="color:#8fa1b3;">subsets</span><span>(vector&lt;</span><span style="color:#b48ead;">int</span><span>&gt;&amp; </span><span style="color:#bf616a;">nums</span><span>) {
</span><span>    </span><span style="color:#65737e;">// 记录走过的路径
</span><span>    vector&lt;</span><span style="color:#b48ead;">int</span><span>&gt; track;
</span><span>    </span><span style="color:#bf616a;">backtrack</span><span>(nums, </span><span style="color:#d08770;">0</span><span>, track);
</span><span>    </span><span style="color:#b48ead;">return</span><span> res;
</span><span>}
</span><span>
</span><span style="color:#b48ead;">void </span><span style="color:#8fa1b3;">backtrack</span><span>(vector&lt;</span><span style="color:#b48ead;">int</span><span>&gt;&amp; </span><span style="color:#bf616a;">nums</span><span>, </span><span style="color:#b48ead;">int </span><span style="color:#bf616a;">start</span><span>, vector&lt;</span><span style="color:#b48ead;">int</span><span>&gt;&amp; </span><span style="color:#bf616a;">track</span><span>) {
</span><span>    res.</span><span style="color:#bf616a;">push_back</span><span>(track);
</span><span>    </span><span style="color:#65737e;">// 注意 i 从 start 开始递增
</span><span>    </span><span style="color:#b48ead;">for </span><span>(</span><span style="color:#b48ead;">int</span><span> i = start; i &lt; nums.</span><span style="color:#bf616a;">size</span><span>(); i++) {
</span><span>        </span><span style="color:#65737e;">// 做选择
</span><span>        track.</span><span style="color:#bf616a;">push_back</span><span>(nums[i]);
</span><span>        </span><span style="color:#65737e;">// 回溯
</span><span>        </span><span style="color:#bf616a;">backtrack</span><span>(nums, i + </span><span style="color:#d08770;">1</span><span>, track);
</span><span>        </span><span style="color:#65737e;">// 撤销选择
</span><span>        track.</span><span style="color:#bf616a;">pop_back</span><span>();
</span><span>    }
</span><span>}
</span></code></pre>
<p>对 <code>res</code> 的更新是一个<strong>前序遍历</strong>，<code>res</code> 就是树上的所有节点</p>
<h3 id="zu-he">组合</h3>
<p>输入两个数字 <code>n, k</code>，算法输出 <code>[1..n]</code> 中 k 个数字的所有组合。</p>
<p>直接套回溯算法模板，<code>k</code> 限制了树的高度，<code>n</code> 限制了树的宽度</p>
<pre data-lang="c++" style="background-color:#2b303b;color:#c0c5ce;" class="language-c++ "><code class="language-c++" data-lang="c++"><span>vector&lt;vector&lt;</span><span style="color:#b48ead;">int</span><span>&gt;&gt;res;
</span><span>
</span><span>vector&lt;vector&lt;</span><span style="color:#b48ead;">int</span><span>&gt;&gt; </span><span style="color:#8fa1b3;">combine</span><span>(</span><span style="color:#b48ead;">int </span><span style="color:#bf616a;">n</span><span>, </span><span style="color:#b48ead;">int </span><span style="color:#bf616a;">k</span><span>) {
</span><span>    </span><span style="color:#b48ead;">if </span><span>(k &lt;= </span><span style="color:#d08770;">0 </span><span>|| n &lt;= </span><span style="color:#d08770;">0</span><span>) </span><span style="color:#b48ead;">return</span><span> res;
</span><span>    vector&lt;</span><span style="color:#b48ead;">int</span><span>&gt; track;
</span><span>    </span><span style="color:#bf616a;">backtrack</span><span>(n, k, </span><span style="color:#d08770;">1</span><span>, track);
</span><span>    </span><span style="color:#b48ead;">return</span><span> res;
</span><span>}
</span><span>
</span><span style="color:#b48ead;">void </span><span style="color:#8fa1b3;">backtrack</span><span>(</span><span style="color:#b48ead;">int </span><span style="color:#bf616a;">n</span><span>, </span><span style="color:#b48ead;">int </span><span style="color:#bf616a;">k</span><span>, </span><span style="color:#b48ead;">int </span><span style="color:#bf616a;">start</span><span>, vector&lt;</span><span style="color:#b48ead;">int</span><span>&gt;&amp; </span><span style="color:#bf616a;">track</span><span>) {
</span><span>    </span><span style="color:#65737e;">// 到达树的底部
</span><span>    </span><span style="color:#b48ead;">if </span><span>(k == track.</span><span style="color:#bf616a;">size</span><span>()) {
</span><span>        res.</span><span style="color:#bf616a;">push_back</span><span>(track);
</span><span>        </span><span style="color:#b48ead;">return</span><span>;
</span><span>    }
</span><span>    </span><span style="color:#65737e;">// 注意 i 从 start 开始递增
</span><span>    </span><span style="color:#b48ead;">for </span><span>(</span><span style="color:#b48ead;">int</span><span> i = start; i &lt;= n; i++) {
</span><span>        </span><span style="color:#65737e;">// 做选择
</span><span>        track.</span><span style="color:#bf616a;">push_back</span><span>(i);
</span><span>        </span><span style="color:#bf616a;">backtrack</span><span>(n, k, i + </span><span style="color:#d08770;">1</span><span>, track);
</span><span>        </span><span style="color:#65737e;">// 撤销选择
</span><span>        track.</span><span style="color:#bf616a;">pop_back</span><span>();
</span><span>    }
</span><span>}
</span></code></pre>
<p><code>backtrack</code> 函数和计算子集的差不多，区别在于，更新 <code>res</code> 的地方是树的底端。</p>
<h3 id="pai-lie">排列</h3>
<p>输入一个不包含重复数字的数组 <code>nums</code>，返回这些数字的全部排列。</p>
<pre data-lang="c++" style="background-color:#2b303b;color:#c0c5ce;" class="language-c++ "><code class="language-c++" data-lang="c++"><span>vector&lt;vector&lt;</span><span style="color:#b48ead;">int</span><span>&gt;&gt;res;
</span><span>
</span><span>vector&lt;vector&lt;</span><span style="color:#b48ead;">int</span><span>&gt;&gt; </span><span style="color:#8fa1b3;">permute</span><span>(vector&lt;</span><span style="color:#b48ead;">int</span><span>&gt;&amp; </span><span style="color:#bf616a;">nums</span><span>) {
</span><span>    </span><span style="color:#b48ead;">if </span><span>(k &lt;= </span><span style="color:#d08770;">0 </span><span>|| n &lt;= </span><span style="color:#d08770;">0</span><span>) </span><span style="color:#b48ead;">return</span><span> res;
</span><span>    vector&lt;</span><span style="color:#b48ead;">int</span><span>&gt; track;
</span><span>    </span><span style="color:#bf616a;">backtrack</span><span>(nums, track);
</span><span>    </span><span style="color:#b48ead;">return</span><span> res;
</span><span>}
</span><span>
</span><span style="color:#b48ead;">void </span><span style="color:#8fa1b3;">backtrack</span><span>(vector&lt;</span><span style="color:#b48ead;">int</span><span>&gt;&amp; </span><span style="color:#bf616a;">nums</span><span>, vector&lt;</span><span style="color:#b48ead;">int</span><span>&gt;&amp; </span><span style="color:#bf616a;">track</span><span>) {
</span><span>    </span><span style="color:#65737e;">// 到达树的底部
</span><span>    </span><span style="color:#b48ead;">if </span><span>(track.</span><span style="color:#bf616a;">size</span><span>() == nums.</span><span style="color:#bf616a;">size</span><span>()) {
</span><span>        res.</span><span style="color:#bf616a;">push_back</span><span>(track);
</span><span>        </span><span style="color:#b48ead;">return</span><span>;
</span><span>    }
</span><span>    </span><span style="color:#b48ead;">for </span><span>(</span><span style="color:#b48ead;">int</span><span> i = </span><span style="color:#d08770;">0</span><span>; i &lt; nums.</span><span style="color:#bf616a;">size</span><span>(); i++) {
</span><span>        </span><span style="color:#65737e;">// 排除不合法的选择
</span><span>        </span><span style="color:#b48ead;">if</span><span>(</span><span style="color:#bf616a;">count</span><span>(track.</span><span style="color:#bf616a;">begin</span><span>(), track.</span><span style="color:#bf616a;">end</span><span>(), nums[i])){
</span><span>            </span><span style="color:#b48ead;">continue</span><span>;
</span><span>        }
</span><span>        </span><span style="color:#65737e;">// 做选择
</span><span>        track.</span><span style="color:#bf616a;">push_back</span><span>(nums[i]);
</span><span>        </span><span style="color:#65737e;">// 进入下一层决策树
</span><span>        </span><span style="color:#bf616a;">backtrack</span><span>(nums, track);
</span><span>        </span><span style="color:#65737e;">// 撤销选择
</span><span>        track.</span><span style="color:#bf616a;">pop_back</span><span>();
</span><span>    }
</span><span>}
</span></code></pre>
<p>排列问题的树比较对称，而组合问题的树越靠右节点越少。</p>
<p>在代码中的体现就是，排列问题每次通过排除在 <code>track</code> 中已经选择过的数字；而组合问题通过传入一个 <code>start</code> 参数，来排除 <code>start</code> 索引之前的数字。</p>
<h2 id="qian-zhui-he">前缀和</h2>
<p>前缀和对于一个给定的数组<code>nums</code>，额外开辟一个前缀和数组进行预处理</p>
<p>例题：算出一共有几个和为 k 的子数组</p>
<pre data-lang="c++" style="background-color:#2b303b;color:#c0c5ce;" class="language-c++ "><code class="language-c++" data-lang="c++"><span style="color:#b48ead;">int </span><span style="color:#8fa1b3;">subarraySum</span><span>(vector&lt;</span><span style="color:#b48ead;">int</span><span>&gt;&amp; </span><span style="color:#bf616a;">nums</span><span>, </span><span style="color:#b48ead;">int </span><span style="color:#bf616a;">k</span><span>) {
</span><span>    </span><span style="color:#b48ead;">int</span><span> n = nums.</span><span style="color:#bf616a;">size</span><span>();
</span><span>    </span><span style="color:#65737e;">//前缀和：该前缀和出现的次数
</span><span>    unordered_map&lt;</span><span style="color:#b48ead;">int</span><span>, </span><span style="color:#b48ead;">int</span><span>&gt; preSum;
</span><span>    </span><span style="color:#65737e;">// base case
</span><span>    preSum[</span><span style="color:#d08770;">0</span><span>] = </span><span style="color:#d08770;">1</span><span>;
</span><span>
</span><span>    </span><span style="color:#b48ead;">int</span><span> ans = </span><span style="color:#d08770;">0</span><span>, sum0_i = </span><span style="color:#d08770;">0</span><span>;
</span><span>    </span><span style="color:#65737e;">// 穷举所有子数组
</span><span>    </span><span style="color:#b48ead;">for </span><span>(</span><span style="color:#b48ead;">int</span><span> i = </span><span style="color:#d08770;">0</span><span>; i &lt; n; i++){
</span><span>        sum0_i += nums[i];
</span><span>        </span><span style="color:#65737e;">// 目标前缀和 nums[0...j]
</span><span>        </span><span style="color:#b48ead;">int</span><span> sum0_j = sum0_i - k;
</span><span>        </span><span style="color:#65737e;">// 如果前面出现过这个前缀和，直接更新答案
</span><span>        </span><span style="color:#b48ead;">if</span><span>(preSum.</span><span style="color:#bf616a;">count</span><span>(sum0_j)){
</span><span>            ans += preSum[sum0_j];
</span><span>        }
</span><span>        preSum[sum0_i]++;
</span><span>    }
</span><span>        
</span><span>
</span><span>    </span><span style="color:#b48ead;">return</span><span> ans;
</span><span>}
</span></code></pre>
<p>例题：统计班上同学考试成绩在不同分数段的百分比</p>
<pre data-lang="java" style="background-color:#2b303b;color:#c0c5ce;" class="language-java "><code class="language-java" data-lang="java"><span style="color:#b48ead;">int[]</span><span> scores; </span><span style="color:#65737e;">// 存储着所有同学的分数
</span><span style="color:#65737e;">// 试卷满分 150 分
</span><span style="color:#b48ead;">int[]</span><span> count = </span><span style="color:#b48ead;">new int</span><span>[</span><span style="color:#d08770;">150 </span><span>+ </span><span style="color:#d08770;">1</span><span>]
</span><span style="color:#65737e;">// 记录每个分数有几个同学
</span><span style="color:#b48ead;">for </span><span>(</span><span style="color:#b48ead;">int</span><span> score : scores)
</span><span>    count[score]++
</span><span style="color:#65737e;">// 构造前缀和
</span><span style="color:#b48ead;">for </span><span>(</span><span style="color:#b48ead;">int</span><span> i = </span><span style="color:#d08770;">1</span><span>; i &lt; count.length; i++)
</span><span>    count[i] = count[i] + count[i-</span><span style="color:#d08770;">1</span><span>];
</span></code></pre>

    </div>

    
    

    <div class="post-footer">
        
            
                <div class="post-tags">
                    
                        <a href="https://arceusj2000.github.io/tags/cram/">#Cram</a>
                    
                </div>
            
            

        

    </div>

    
    
</article>


                </div>
            </main>

            
            
        </div>

      
          <script type="text/javascript" src="https://arceusj2000.github.io/even.js" ></script>
      
    </body>

</html>
