<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom" xml:lang="zh">
    <title>Fang Li - vjvm</title>
    <subtitle>Fang L&#x27;s Blog</subtitle>
    <link href="https://ffangl.github.io/tags/vjvm/atom.xml" rel="self" type="application/atom+xml"/>
    <link href="https://ffangl.github.io"/>
    <generator uri="https://www.getzola.org/">Zola</generator>
    <updated>2023-02-24T17:47:19+00:00</updated>
    <id>https://ffangl.github.io/tags/vjvm/atom.xml</id>
    <entry xml:lang="zh">
        <title>vjvm note 04： Instruction</title>
        <published>2023-02-24T17:47:19+00:00</published>
        <updated>2023-02-24T17:47:19+00:00</updated>
        <author>
          <name>Unknown</name>
        </author>
        <link rel="alternate" href="https://ffangl.github.io/202302241747/" type="text/html"/>
        <id>https://ffangl.github.io/202302241747/</id>
        
        <content type="html">&lt;span id=&quot;continue-reading&quot;&gt;&lt;&#x2F;span&gt;&lt;h2 id=&quot;instruction&quot;&gt;Instruction&lt;&#x2F;h2&gt;
&lt;p&gt;从实现上来说，所有的指令都是对操作数栈、局部变量表等数据结构里面的某处数据进行了修改。&lt;&#x2F;p&gt;
&lt;p&gt;每条指令的执行都分为解码与运行两个阶段。解码由指令的构造方法实现（如 &lt;code&gt;invokestatic&lt;&#x2F;code&gt;），而运行则由 &lt;code&gt;run&lt;&#x2F;code&gt; 方法实现。&lt;&#x2F;p&gt;
&lt;p&gt;除此之外，每条指令有一个 &lt;code&gt;toString&lt;&#x2F;code&gt; 方法，被调试器使用。&lt;&#x2F;p&gt;
&lt;p&gt;指令执行时， 首先会读取每条指令的第一个字节，然后查询&lt;code&gt;Decoder.decodeTable&lt;&#x2F;code&gt;进行解码。&lt;code&gt;Decoder.decodeTable&lt;&#x2F;code&gt;是一个从 opcode 到对应指令解码方法的映射。&lt;&#x2F;p&gt;
&lt;p&gt;解码方法使用了统一的接口：&lt;code&gt;Instruction (ProgramCounter, MethodInfo)&lt;&#x2F;code&gt;。第一个参数为指向当前指令的程序计数器，第二个是当前指令所在的类。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;invokestaticzhi-ling&quot;&gt;invokestatic指令&lt;&#x2F;h2&gt;
&lt;p&gt;实现了两个功能：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;解析：&lt;&#x2F;p&gt;
&lt;p&gt;invokestatic编码了一个 unsigned short 指向当前类常量池中一个 CONSTANT_Methodref_info 常量，首先加载该方法所在类，然后从加载的类中找到与 &lt;code&gt;Methodref&lt;&#x2F;code&gt; 相符的 &lt;code&gt;MethodInfo&lt;&#x2F;code&gt; 并保存至指令中。&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;运行：&lt;&#x2F;p&gt;
&lt;p&gt;首先从当前方法的操作数栈顶弹出 &lt;code&gt;argc&lt;&#x2F;code&gt; 个 slots，即弹出方法调用的参数。然后通过 &lt;code&gt;Interpreter.invoke&lt;&#x2F;code&gt; 调用方法。 &lt;code&gt;MethodDescriptors.argc&lt;&#x2F;code&gt; 用于计算参数占用的 slots 数量。&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;color:#c0c5ce;&quot;&gt;&lt;code&gt;&lt;span&gt;argc(descriptor &#x2F;* 方法描述符，如 (I[JLjava&#x2F;lang&#x2F;String;)V *&#x2F;):
&lt;&#x2F;span&gt;&lt;span&gt;  argc = 0
&lt;&#x2F;span&gt;&lt;span&gt;  n = 0
&lt;&#x2F;span&gt;&lt;span&gt;  while 该方法有第 n 个参数:
&lt;&#x2F;span&gt;&lt;span&gt;    desc = 第 n 个参数的描述符，在以上例子中分别为 I、[J 与 Ljava&#x2F;lang&#x2F;String;
&lt;&#x2F;span&gt;&lt;span&gt;    size = desc 对应类型所占的槽位数。Long 和 Double 为 2，其它为 1
&lt;&#x2F;span&gt;&lt;span&gt;    argc += size
&lt;&#x2F;span&gt;&lt;span&gt;    n += 1
&lt;&#x2F;span&gt;&lt;span&gt;  return argc
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;INVOKESTATIC(pc &#x2F;* 当前 PC *&#x2F;, method &#x2F;* 当前指令所在方法 *&#x2F;):
&lt;&#x2F;span&gt;&lt;span&gt;  cp = 当前类的常量池
&lt;&#x2F;span&gt;&lt;span&gt;  methodRef = cp[从 PC 读取下标]
&lt;&#x2F;span&gt;&lt;span&gt;  thisClass = method 所在的类
&lt;&#x2F;span&gt;&lt;span&gt;  jClass = 使用 thisClass 中的 classLoader 加载 methodRef 指向的类
&lt;&#x2F;span&gt;&lt;span&gt;  this.method = 使用 findMethod 在 jClass 中查找与 methodRef 匹配的方法
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;run(thread &#x2F;* 执行时的线程 *&#x2F;):
&lt;&#x2F;span&gt;&lt;span&gt;  stack = 线程当前栈帧的操作数栈
&lt;&#x2F;span&gt;&lt;span&gt;  argc = 使用 MethodDescriptors.argc 计算方法参数占用的 slots 数量
&lt;&#x2F;span&gt;&lt;span&gt;  interpreter = 解释器
&lt;&#x2F;span&gt;&lt;span&gt;  args = 从 stack 顶部弹出 argc 个 slots
&lt;&#x2F;span&gt;&lt;span&gt;  使用 interpreter.invoke 调用方法
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h2 id=&quot;dai-ma&quot;&gt;代码&lt;&#x2F;h2&gt;
&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;ffangli&#x2F;toyjvm&quot;&gt;ffangli&#x2F;toyjvm (github.com)&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;bash&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-bash &quot;&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;$&lt;&#x2F;span&gt;&lt;span&gt; tree src&#x2F;main&#x2F;java&#x2F;vjvm&#x2F;interpreter
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
</content>
        
    </entry>
    <entry xml:lang="zh">
        <title>vjvm note 03： Runtime</title>
        <published>2023-02-21T02:47:19+00:00</published>
        <updated>2023-02-21T02:47:19+00:00</updated>
        <author>
          <name>Unknown</name>
        </author>
        <link rel="alternate" href="https://ffangl.github.io/202302210247/" type="text/html"/>
        <id>https://ffangl.github.io/202302210247/</id>
        
        <content type="html">&lt;span id=&quot;continue-reading&quot;&gt;&lt;&#x2F;span&gt;&lt;h2 id=&quot;slotsyu-operandstack&quot;&gt;Slots与OperandStack&lt;&#x2F;h2&gt;
&lt;p&gt;Slots代表规范中定义的JVM插槽数组。它支持获取和放置原始数据类型，包括地址。使用对象数组Object[]实现。&lt;&#x2F;p&gt;
&lt;p&gt;在局部变量表和操作数栈中，每个位置都是 4 字节，且 &lt;code&gt;long&lt;&#x2F;code&gt; 与 &lt;code&gt;double&lt;&#x2F;code&gt; 占用连续两个位置。&lt;&#x2F;p&gt;
&lt;p&gt;规定每个 &lt;code&gt;int&lt;&#x2F;code&gt; 所占空间为一个槽位（slot），&lt;code&gt;long&lt;&#x2F;code&gt; 与 &lt;code&gt;double&lt;&#x2F;code&gt; 占用两个槽位， 且使用第一个的下标访问。Slots 的下标从 0 开始。在初始化时，能够确定最多使用的 slots 数量 &lt;code&gt;slotSize&lt;&#x2F;code&gt;，它可能来自 &lt;code&gt;Code&lt;&#x2F;code&gt; 属性中的 &lt;code&gt;max_stack&lt;&#x2F;code&gt; 或 &lt;code&gt;max_locals&lt;&#x2F;code&gt;。 对于每一种基本数据类型，都提供了对应的 getter 与 setter 方法（无 get 与 set 前缀），其中 &lt;code&gt;byte&lt;&#x2F;code&gt;、&lt;code&gt;char&lt;&#x2F;code&gt; 与 &lt;code&gt;short&lt;&#x2F;code&gt; 类型应转换成 &lt;code&gt;int&lt;&#x2F;code&gt; 存储。Slots 的大小可通过 &lt;code&gt;size&lt;&#x2F;code&gt; 方法获得。在进行函数调用时，参数首先从操作数栈的栈顶弹出，然后被复制进被调用方法栈帧的局部变量表中。通过 &lt;code&gt;copyTo&lt;&#x2F;code&gt; 与&lt;code&gt;popSlots&lt;&#x2F;code&gt; 支持这种操作。&lt;&#x2F;p&gt;
&lt;p&gt;JVM 在操作数栈和局部变量表中并不会保存 char、byte、short 和 bool 类型的值，而是把它们转换成 int。在使用具体类型的 get 与 set 方法时，每个位置 set 的类型必须和 get 的类型相同。&lt;&#x2F;p&gt;
&lt;p&gt;&lt;code&gt;OperandStack&lt;&#x2F;code&gt; 负责维护Slots，只需额外维护栈顶的位置，在压栈或出栈时自动更新。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;code-yu-programcounter&quot;&gt;Code 与 ProgramCounter&lt;&#x2F;h2&gt;
&lt;p&gt;为了执行字节码，需要首先将它保存在对应的方法中。Class 文件的字节码在方法的 &lt;code&gt;Code&lt;&#x2F;code&gt; 属性里，见&lt;em&gt;src&#x2F;main&#x2F;java&#x2F;vjvm&#x2F;runtime&#x2F;classdata&#x2F;attribute&#x2F;Code.java&lt;&#x2F;em&gt;，在&lt;code&gt;MethodInfo&lt;&#x2F;code&gt; 中调用它解析 &lt;code&gt;Code&lt;&#x2F;code&gt; 属性。&lt;&#x2F;p&gt;
&lt;p&gt;在 VJVM 中，每个栈帧都有自己独立的 PC，指向所执行方法的字节码，而整个线程使用最顶部栈帧的 PC。&lt;code&gt;ProgramCounter&lt;&#x2F;code&gt; 使用一个 &lt;code&gt;ByteBuffer&lt;&#x2F;code&gt; 来包装原始字节码，并提供了 &lt;code&gt;byte_&lt;&#x2F;code&gt;、&lt;code&gt;ubyte&lt;&#x2F;code&gt; 等方法读取数据同时向前移动。这样，在我们读取完一条指令并解码后，PC 自然就指向了下一条指令。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;jthread-yu-jframe&quot;&gt;JThread 与 JFrame&lt;&#x2F;h2&gt;
&lt;p&gt;使用 &lt;code&gt;JThread&lt;&#x2F;code&gt; 代表一个线程，&lt;code&gt;JFrame&lt;&#x2F;code&gt; 代表一个线程的单个栈帧。&lt;&#x2F;p&gt;
&lt;p&gt;&lt;code&gt;VMContext&lt;&#x2F;code&gt; 中使用 &lt;code&gt;ArrayList&lt;&#x2F;code&gt; 保存 &lt;code&gt;JThread&lt;&#x2F;code&gt;。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;instruction-yu-jinterpreter&quot;&gt;Instruction 与 JInterpreter&lt;&#x2F;h2&gt;
&lt;p&gt;VJVM 运行一个 Java 程序的流程：运行程序的命令通过 &lt;code&gt;vm.Run&lt;&#x2F;code&gt; 类实现，其中会首先初始化运行时环境，然后调用 &lt;code&gt;VMContext.run&lt;&#x2F;code&gt; 执行程序。在&lt;code&gt;VMContext&lt;&#x2F;code&gt; 中，会首先加载用户指定的主类并寻找其中的 &lt;code&gt;main&lt;&#x2F;code&gt; 方法。在找到之后将它交给解释器 &lt;code&gt;JInterpreter&lt;&#x2F;code&gt; 执行（在这里额外传入了一个 &lt;code&gt;Slots&lt;&#x2F;code&gt;，代表 &lt;code&gt;main&lt;&#x2F;code&gt; 函数的参数）。&lt;&#x2F;p&gt;
&lt;p&gt;解释器首先利用方法和参数构造一个栈帧，在 &lt;code&gt;JFrame&lt;&#x2F;code&gt; 构造方法中将参数压栈，然后进入程序主循环 &lt;code&gt;run&lt;&#x2F;code&gt; 方法解释执行指令。&lt;&#x2F;p&gt;
&lt;p&gt;在 VJVM 中，把执行一条指令分为解码与执行两部分。每个指令通过公共的 &lt;code&gt;Instruction.run&lt;&#x2F;code&gt; 接口执行，而解码则由 &lt;code&gt;Decoder.decode&lt;&#x2F;code&gt; 完成。&lt;&#x2F;p&gt;
&lt;p&gt;使用了一个巨大的表来解码指令。&lt;code&gt;Decoder.decodeTable&lt;&#x2F;code&gt; 有 256 个表项，其中的每一项对应指令第一个字节 &lt;code&gt;opcode&lt;&#x2F;code&gt;。解码时，首先读取 &lt;code&gt;opcode&lt;&#x2F;code&gt;，然后查表调用相应函数来解码指令。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;fang-fa-diao-yong&quot;&gt;方法调用&lt;&#x2F;h2&gt;
&lt;p&gt;通过 &lt;code&gt;JInterpreter.invoke&lt;&#x2F;code&gt; 进行调用。该方法接受三个参数：需调用的方法、当前线程与参数。它会创建一个新的栈帧，将参数复制到新栈帧的局部变量表中，并将栈帧压到当前线程的栈顶。在完成准备之后，解释器会进入 &lt;code&gt;run&lt;&#x2F;code&gt; 执行该方法的代码。虚拟机启动时，会在 &lt;code&gt;VMContext.run&lt;&#x2F;code&gt; 中调用 &lt;code&gt;main&lt;&#x2F;code&gt; 函数。&lt;&#x2F;p&gt;
&lt;p&gt;框架代码使用 native 方法实现了输入输出功能。在 &lt;code&gt;testdata&lt;&#x2F;code&gt; 中的 &lt;code&gt;IOUtil&lt;&#x2F;code&gt; 类，提供了打印数据到标准输出和从标准输入读取数据的方法。相应地，解释器中对于这几个方法作了特殊处理：当其中一个方法被调用时，不会解释执行 Java 代码（几个方法也根本没有 &lt;code&gt;Code&lt;&#x2F;code&gt; 属性），而是直接在 VM 中实现了输入和输出的功能。native 方法的执行通过 &lt;code&gt;runNativeMethod&lt;&#x2F;code&gt; 实现。&lt;&#x2F;p&gt;
&lt;p&gt;事实上，标准的 JVM 中输入输出也是通过类似方式实现的。JVM 本身只能进行计算，并不能读取或写入数据。为了完成 IO 任务，JVM 将 native 方法绑定到对应的 C 函数上，并通过 C 函数与操作系统交互。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;dai-ma&quot;&gt;代码&lt;&#x2F;h2&gt;
&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;ffangli&#x2F;toyjvm&quot;&gt;ffangli&#x2F;toyjvm (github.com)&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;bash&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-bash &quot;&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;$&lt;&#x2F;span&gt;&lt;span&gt; tree src&#x2F;main&#x2F;java&#x2F;vjvm&#x2F;runtime
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
</content>
        
    </entry>
    <entry xml:lang="zh">
        <title>vjvm note 02： Parser</title>
        <published>2023-02-15T22:47:19+00:00</published>
        <updated>2023-02-15T22:47:19+00:00</updated>
        <author>
          <name>Unknown</name>
        </author>
        <link rel="alternate" href="https://ffangl.github.io/202302152247/" type="text/html"/>
        <id>https://ffangl.github.io/202302152247/</id>
        
        <content type="html">&lt;span id=&quot;continue-reading&quot;&gt;&lt;&#x2F;span&gt;&lt;h2 id=&quot;class-wen-jian-jie-gou&quot;&gt;class 文件结构&lt;&#x2F;h2&gt;
&lt;pre data-lang=&quot;c&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-c &quot;&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;&lt;span&gt;ClassFile {
&lt;&#x2F;span&gt;&lt;span&gt;  u4              magic;
&lt;&#x2F;span&gt;&lt;span&gt;  u2              minor_version;
&lt;&#x2F;span&gt;&lt;span&gt;  u2              major_version;
&lt;&#x2F;span&gt;&lt;span&gt;  u2              constant_pool_count;
&lt;&#x2F;span&gt;&lt;span&gt;  cp_info         constant_pool[constant_pool_count - &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;]; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; 常量池
&lt;&#x2F;span&gt;&lt;span&gt;  u2              access_flags;
&lt;&#x2F;span&gt;&lt;span&gt;  u2              this_class;
&lt;&#x2F;span&gt;&lt;span&gt;  u2              super_class;
&lt;&#x2F;span&gt;&lt;span&gt;  u2              interfaces_count;
&lt;&#x2F;span&gt;&lt;span&gt;  u2              interfaces[interfaces_count]; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; 类实现的接口
&lt;&#x2F;span&gt;&lt;span&gt;  u2              fields_count;
&lt;&#x2F;span&gt;&lt;span&gt;  field_info      fields[fields_count]; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; 类的成员变量
&lt;&#x2F;span&gt;&lt;span&gt;  u2              methods_count;
&lt;&#x2F;span&gt;&lt;span&gt;  method_info     methods[methods_count]; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; 类的方法
&lt;&#x2F;span&gt;&lt;span&gt;  u2              attributes_count;
&lt;&#x2F;span&gt;&lt;span&gt;  attribute_info  attributes[attributes_count];
&lt;&#x2F;span&gt;&lt;span&gt;};
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;每一行的前一列是类型，后一列是名称。例如，&lt;code&gt;u4 magic&lt;&#x2F;code&gt; 代表 &lt;code&gt;magic&lt;&#x2F;code&gt; 为 32 位无符号整形。在一个 class 文件中，最重要的四个结构是常量池（Constant Pool）、 成员变量（Field）、方法（Method）和属性（Attribute）。&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;常量池（Constant Pool）这里的 &lt;code&gt;info&lt;&#x2F;code&gt; 成员的长度是可变的。&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;pre data-lang=&quot;c&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-c &quot;&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;&lt;span&gt;cp_info {
&lt;&#x2F;span&gt;&lt;span&gt;  u1  tag; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; 常量类型
&lt;&#x2F;span&gt;&lt;span&gt;  u1  info[]; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; 常量数据
&lt;&#x2F;span&gt;&lt;span&gt;};
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;比如，对于 &lt;code&gt;CONSTANT_Class_info&lt;&#x2F;code&gt;：&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;color:#c0c5ce;&quot;&gt;&lt;code&gt;&lt;span&gt;struct CONSTANT_Class_info {
&lt;&#x2F;span&gt;&lt;span&gt;  u1  tag;
&lt;&#x2F;span&gt;&lt;span&gt;  u2  name_index;
&lt;&#x2F;span&gt;&lt;span&gt;};
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;这里的 &lt;code&gt;info&lt;&#x2F;code&gt; 就被替换成了两个字节的索引，指向常量池中代表这个类名称的项。&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;成员变量（Field） 其中的 &lt;code&gt;name_index&lt;&#x2F;code&gt; 和 &lt;code&gt;descriptor_index&lt;&#x2F;code&gt; 都指向常量池的内容。&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;pre data-lang=&quot;c&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-c &quot;&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;&lt;span&gt;field_info {
&lt;&#x2F;span&gt;&lt;span&gt; u2 access_flags;
&lt;&#x2F;span&gt;&lt;span&gt; u2 name_index;
&lt;&#x2F;span&gt;&lt;span&gt; u2 descriptor_index;
&lt;&#x2F;span&gt;&lt;span&gt; u2 attributes_count;
&lt;&#x2F;span&gt;&lt;span&gt; attribute_info attributes[attributes_count];
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;ul&gt;
&lt;li&gt;方法（Method）&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;pre data-lang=&quot;c&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-c &quot;&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;&lt;span&gt;method_info {
&lt;&#x2F;span&gt;&lt;span&gt; u2 access_flags;
&lt;&#x2F;span&gt;&lt;span&gt; u2 name_index;
&lt;&#x2F;span&gt;&lt;span&gt; u2 descriptor_index;
&lt;&#x2F;span&gt;&lt;span&gt; u2 attributes_count;
&lt;&#x2F;span&gt;&lt;span&gt; attribute_info attributes[attributes_count];
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;ul&gt;
&lt;li&gt;属性（Attribute）属性在类、成员变量和方法的结构中出现，一个属性的通用结构如下：&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;pre style=&quot;background-color:#2b303b;color:#c0c5ce;&quot;&gt;&lt;code&gt;&lt;span&gt;attribute_info {
&lt;&#x2F;span&gt;&lt;span&gt; u2 attribute_name_index;
&lt;&#x2F;span&gt;&lt;span&gt; u4 attribute_length;
&lt;&#x2F;span&gt;&lt;span&gt; u1 info[attribute_length];
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;属性中保存了许多内容，如 &lt;code&gt;static final&lt;&#x2F;code&gt; 变量的值、方法的代码、异常处理所需的信息等。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;duo-xing-qiu-zhi-he-ji-zao-qiu-zhi&quot;&gt;惰性求值和及早求值&lt;&#x2F;h2&gt;
&lt;p&gt;惰性求值（Lazy Evaluation）在需要时才进行计算&lt;&#x2F;p&gt;
&lt;p&gt;及早求值  (Eager Evaluation) 在构造时就把全部值计算出来&lt;&#x2F;p&gt;
&lt;h2 id=&quot;dai-ma&quot;&gt;代码&lt;&#x2F;h2&gt;
&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;ffangli&#x2F;toyjvm&quot;&gt;ffangli&#x2F;toyjvm (github.com)&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;bash&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-bash &quot;&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;$&lt;&#x2F;span&gt;&lt;span&gt; tree src&#x2F;main&#x2F;java&#x2F;vjvm&#x2F;classfiledefs
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;$&lt;&#x2F;span&gt;&lt;span&gt; tree src&#x2F;main&#x2F;java&#x2F;vjvm&#x2F;runtime&#x2F;classdata
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h2 id=&quot;can-kao-wen-xian&quot;&gt;参考文献&lt;&#x2F;h2&gt;
&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;docs.oracle.com&#x2F;javase&#x2F;specs&#x2F;jvms&#x2F;se8&#x2F;jvms8.pdf&quot;&gt;The Java® Virtual Machine Specification (oracle.com)&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
</content>
        
    </entry>
    <entry xml:lang="zh">
        <title>vjvm note 01： ClassLoader</title>
        <published>2023-02-13T20:47:19+00:00</published>
        <updated>2023-02-13T20:47:19+00:00</updated>
        <author>
          <name>Unknown</name>
        </author>
        <link rel="alternate" href="https://ffangl.github.io/202302132047/" type="text/html"/>
        <id>https://ffangl.github.io/202302132047/</id>
        
        <content type="html">&lt;span id=&quot;continue-reading&quot;&gt;&lt;&#x2F;span&gt;
&lt;h2 id=&quot;classloader&quot;&gt;ClassLoader&lt;&#x2F;h2&gt;
&lt;p&gt;作为Java运行时环境的一部分，Java ClassLoader动态地将Java类加载到Java虚拟机中。通过在Java中使用类加载器，它不需要Java运行时系统了解文件和文件系统的情况。Java类在应用程序需要时被加载，而不是一次性加载到内存中。Java中的ClassLoader是由JRE调用的。这些ClassLoaders动态地将类加载到内存中。&lt;&#x2F;p&gt;
&lt;p&gt;在java中，有以下3种默认的类加载器:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Bootstrap ClassLoader:&lt;&#x2F;strong&gt; Loads class from JRE&#x2F;lib&#x2F;rt.jar&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;Extension ClassLoader:&lt;&#x2F;strong&gt; Loads class from JRE&#x2F;lib&#x2F;ext&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;Application ClassLoader:&lt;&#x2F;strong&gt; Loads class from CLASSPATH environment variable&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h2 id=&quot;shuang-qin-wei-tuo-jia-zai-ji-zhi-parent-first&quot;&gt;双亲委托加载机制（Parent-First）&lt;&#x2F;h2&gt;
&lt;p&gt;ClassLoader委托层次模型的运作顺序是:&lt;&#x2F;p&gt;
&lt;p&gt;Application ClassLoader -&amp;gt; Extension ClassLoader -&amp;gt; Bootstrap ClassLoader&lt;&#x2F;p&gt;
&lt;p&gt;Java 默认使用了名为 parent-first 的策略：每个 loader（除 Bootstrap Loader 外）均有一个&lt;strong&gt;亲代加载器 （parent）&lt;&#x2F;strong&gt;，在搜索 class 时首先委托亲代进行搜索，找不到时才搜索自己的加载路径。 于是，各个 ClassLoader 之间就形成了如下的委托关系：&lt;&#x2F;p&gt;
&lt;img src=&quot;.\img\loader-hierarchy.png&quot; style=&quot;zoom:80%;&quot; &#x2F;&gt;
&lt;pre style=&quot;background-color:#2b303b;color:#c0c5ce;&quot;&gt;&lt;code&gt;&lt;span&gt;if 需要加载的 class 已被保存在 definedClass 中：
&lt;&#x2F;span&gt;&lt;span&gt;    返回已加载的 class
&lt;&#x2F;span&gt;&lt;span&gt;else if parent 不为 null：
&lt;&#x2F;span&gt;&lt;span&gt;    使用 parent 加载 class
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;if parent 未找到相应的 class：
&lt;&#x2F;span&gt;&lt;span&gt;    for searchPaths 中的每一项：
&lt;&#x2F;span&gt;&lt;span&gt;        尝试使用它来加载类，并调用 JClass 构造函数构造类
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;if 所有的 searchPath 都没有找到需要加载的类：
&lt;&#x2F;span&gt;&lt;span&gt;    返回 null
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;在查找 class 文件时，一个 loader 可能会搜索以下两种路径：&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;搜索单个目录&lt;&#x2F;p&gt;
&lt;p&gt;在指定 &lt;code&gt;&#x2F;foo&lt;&#x2F;code&gt; 为加载路径时，如果加载 &lt;code&gt;bar.A&lt;&#x2F;code&gt; 类，你应该查找 &lt;code&gt;&#x2F;foo&#x2F;bar&#x2F;A.class&lt;&#x2F;code&gt; 文件。&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;单个 Jar 文件&lt;&#x2F;p&gt;
&lt;p&gt;Jar 文件事实上是一个 zip 压缩包，将多个 class 文件打包在一起。在从 &lt;code&gt;&#x2F;foo&#x2F;bar.jar&lt;&#x2F;code&gt; 中加载 &lt;code&gt;baz.B&lt;&#x2F;code&gt; 时，你应该读取该文件并搜索其中的 &lt;code&gt;baz&#x2F;B.class&lt;&#x2F;code&gt;路径。JDK 中提供了 &lt;code&gt;JarFile&lt;&#x2F;code&gt; 类来读取 jar 文件。（可以使用 &lt;code&gt;jar -tf &amp;lt;jarfile&amp;gt;&lt;&#x2F;code&gt; 查看 Jar 文件的内容）&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;h2 id=&quot;jclassloader&quot;&gt;JClassLoader&lt;&#x2F;h2&gt;
&lt;p&gt;负责实现上述功能。&lt;&#x2F;p&gt;
&lt;p&gt;JClassLoader首先检查所请求的类是否已经被定义，如果是就返回它。如果父类加载器不是空的，它将尝试使用父类加载器来加载该类。如果失败了，它就依次尝试使用每个类的搜索路径来加载该类。&lt;&#x2F;p&gt;
&lt;p&gt;当成功找到一个类时，代码会使用DataInputStream构造一个JClass对象并缓存结果。close()方法也被实现，以便在不再需要类加载器时关闭每个类的搜索路径。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;classsearchpath&quot;&gt;ClassSearchPath&lt;&#x2F;h2&gt;
&lt;p&gt;一个抽象类，为不同类型的搜索路径提供了一个通用接口，包括类文件或 JAR 文件。&lt;&#x2F;p&gt;
&lt;p&gt;该类有一个静态方法 constructSearchPath，它接收一个代表搜索类文件的路径的字符串。这个字符串使用系统的路径分隔符被分割成不同的路径，并且为每个路径创建一个 ClassSearchPath 对象。如果路径以 .jar 结尾，那么就会创建一个 JarFileSearchPath 对象，否则就会创建一个 ClassFileSearchPath 对象。&lt;&#x2F;p&gt;
&lt;p&gt;findClass 方法接收一个代表要查找的类的名称的字符串，如果找到了，则返回一个包含该类的二进制数据的 InputStream，如果没有找到，则返回 null。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;dai-ma&quot;&gt;代码&lt;&#x2F;h2&gt;
&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;ffangli&#x2F;toyjvm&quot;&gt;ffangli&#x2F;toyjvm (github.com)&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;color:#c0c5ce;&quot;&gt;&lt;code&gt;&lt;span&gt;$ tree src&#x2F;main&#x2F;java&#x2F;vjvm&#x2F;classloader
&lt;&#x2F;span&gt;&lt;span&gt;src&#x2F;main&#x2F;java&#x2F;vjvm&#x2F;classloader
&lt;&#x2F;span&gt;&lt;span&gt;├── searchpath
&lt;&#x2F;span&gt;&lt;span&gt;│   └── ClassSearchPath.java
&lt;&#x2F;span&gt;&lt;span&gt;        DirSearchPath.java
&lt;&#x2F;span&gt;&lt;span&gt;        JarSearchPath.java
&lt;&#x2F;span&gt;&lt;span&gt;        ModuleSearchPath.java
&lt;&#x2F;span&gt;&lt;span&gt;└──JClassLoader.java
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
</content>
        
    </entry>
    <entry xml:lang="zh">
        <title>vjvm note 00： Basic Info</title>
        <published>2022-02-11T20:47:19+00:00</published>
        <updated>2022-02-11T20:47:19+00:00</updated>
        <author>
          <name>Unknown</name>
        </author>
        <link rel="alternate" href="https://ffangl.github.io/202202112047/" type="text/html"/>
        <id>https://ffangl.github.io/202202112047/</id>
        
        <content type="html">&lt;span id=&quot;continue-reading&quot;&gt;&lt;&#x2F;span&gt;
&lt;p&gt;toy jvm，本系列blog用于记录基本项目结构和重要的实现方法&lt;&#x2F;p&gt;
&lt;h2 id=&quot;main&quot;&gt;Main&lt;&#x2F;h2&gt;
&lt;p&gt;定义了一个实现了Callable&lt;Integer&gt;接口的Main类。Main方法创建了一个Main类的新实例，并通过将命令行参数传递给CommandLine类的execute方法来执行。&lt;&#x2F;p&gt;
&lt;p&gt;Main类使用PicoCLI库的注释定义了几个字段和选项。userClassPath字段是一个选项，指定了搜索类文件的类路径。entryClass参数指定要运行的类，args参数指定传递给Java程序的参数。dump选项指定是否要转储classfile的内容。&lt;&#x2F;p&gt;
&lt;p&gt;&lt;code&gt;call&lt;&#x2F;code&gt;方法是该程序的主要逻辑入口。使用指定的userClassPath创建一个新的VMContext类的实例。如果转储（dump ）选项被启用，它使用VMContext类的userLoader方法加载指定的类，并使用转储方法转储其内容。否则，将使用VMContext类的run方法运行指定的类。&lt;&#x2F;p&gt;
&lt;p&gt;dump方法接收一个JClass对象作为输入，并使用Logger类转储其内容。该方法打印出类的名称、次要和主要版本、访问标志、本类、超类、常量池、接口、字段和方法。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;vmcontext&quot;&gt;VMContext&lt;&#x2F;h2&gt;
&lt;p&gt;VMContext负责为运行Java字节码设置上下文。&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;bootstrapLoader：JClassLoader的一个实例，用于从Java Runtime Environment的bootstrap classpath加载类。&lt;&#x2F;li&gt;
&lt;li&gt;userLoader：JClassLoader的一个实例，用于从用户指定的classpath中加载类。&lt;&#x2F;li&gt;
&lt;li&gt;interpreter：JInterpreter的一个实例，用于解释Java字节码指令。&lt;&#x2F;li&gt;
&lt;li&gt;threads：JThread实例的列表，代表JVM中的线程。&lt;&#x2F;li&gt;
&lt;li&gt;heap：JHeap的一个实例，用于管理JVM中的内存。&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;构造函数需要一个userClassPath参数，该参数用于初始化userLoader。构造函数还初始化了bootstrapLoader和解释器，并设置了堆。&lt;&#x2F;p&gt;
&lt;p&gt;run()方法需要一个 entryClass 参数，它是包含要执行的主方法的类的名称。它创建一个新的JThread实例，将其添加到线程列表中，用userLoader加载 entryClass，并找到main方法。然后，它使用解释器调用主方法。&lt;&#x2F;p&gt;
&lt;p&gt;getSystemSearchPaths() 方法返回一个代表系统 classpath 的 ClassSearchPath 实例数组，返回 ModuleSearchPath 的实例。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;dai-ma&quot;&gt;代码&lt;&#x2F;h2&gt;
&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;ffangli&#x2F;toyjvm&quot;&gt;ffangli&#x2F;toyjvm (github.com)&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
</content>
        
    </entry>
</feed>
