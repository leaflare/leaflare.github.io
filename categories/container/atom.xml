<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom" xml:lang="zh">
    <title>Leaflare - Container</title>
    <subtitle>Fang&#x27;s Blog</subtitle>
    <link href="https://leaflare.github.io/categories/container/atom.xml" rel="self" type="application/atom+xml"/>
    <link href="https://leaflare.github.io"/>
    <generator uri="https://www.getzola.org/">Zola</generator>
    <updated>2023-05-06T14:47:19+00:00</updated>
    <id>https://leaflare.github.io/categories/container/atom.xml</id>
    <entry xml:lang="zh">
        <title>Kubernetes 实践记录</title>
        <published>2023-05-06T14:47:19+00:00</published>
        <updated>2023-05-06T14:47:19+00:00</updated>
        <author>
          <name>Unknown</name>
        </author>
        <link rel="alternate" href="https://leaflare.github.io/202305061447/" type="text/html"/>
        <id>https://leaflare.github.io/202305061447/</id>
        
        <content type="html">&lt;span id=&quot;continue-reading&quot;&gt;&lt;&#x2F;span&gt;&lt;h2 id=&quot;xiang-guan-gai-nian&quot;&gt;相关概念&lt;&#x2F;h2&gt;
&lt;h3 id=&quot;servicehe-podde-guan-xi&quot;&gt;service和pod的关系&lt;&#x2F;h3&gt;
&lt;p&gt;在 Kubernetes 中，Service 和 Pod 之间是一种逻辑上的关系，用于解决 Kubernetes 集群中服务的发现和负载均衡问题。&lt;&#x2F;p&gt;
&lt;p&gt;Pod 是 Kubernetes 中最小的可部署对象，通常包含一个或多个容器。Pod 可以单独部署，也可以由 Deployment、StatefulSet 等控制器管理。Pod 可以有自己的 IP 地址和端口号，但这些 IP 地址和端口号是暴露在集群内部的，外部无法直接访问。&lt;&#x2F;p&gt;
&lt;p&gt;Service 则提供了一种将 Pod 暴露给集群外部的方法，通过 Service，可以将 Pod 的 IP 地址和端口号映射到一个 Kubernetes 集群内的虚拟 IP 地址和端口号。当 Service 接收到请求时，它会根据一定的负载均衡算法将请求转发到后端 Pod 中的一个或多个容器中，实现负载均衡和高可用性。&lt;&#x2F;p&gt;
&lt;p&gt;Service 和 Pod 的关系可以看作是一种映射关系，Service 可以将多个 Pod 绑定到同一个 IP 地址和端口号上，并通过负载均衡算法将请求转发到这些 Pod 上，从而实现对 Pod 的访问和管理。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;chang-yong-zhi-ling&quot;&gt;常用指令&lt;&#x2F;h2&gt;
&lt;p&gt;获取K8s集群下pod的信息&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;color:#c0c5ce;&quot;&gt;&lt;code&gt;&lt;span&gt;kubectl get pod # 同理 kubectl get service
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;运行镜像&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;color:#c0c5ce;&quot;&gt;&lt;code&gt;&lt;span&gt;kubectl run pod名称 --image 镜像名称
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;便于调试&#x2F;运行完自动删除的常用命令：&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;color:#c0c5ce;&quot;&gt;&lt;code&gt;&lt;span&gt;kubectl run pod名 --restart=Never --rm -i --tty --image 镜像名 --image-pull-policy=Never --port=端口号 -- &#x2F;bin&#x2F;sh
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;查看运行状态&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;color:#c0c5ce;&quot;&gt;&lt;code&gt;&lt;span&gt;kubectl describe pod pod名 &#x2F; service service名
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;将配置应用到pod&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;color:#c0c5ce;&quot;&gt;&lt;code&gt;&lt;span&gt;kubectl apply -f deployment.yaml  #也可以用pod.json
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;删除pod&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;color:#c0c5ce;&quot;&gt;&lt;code&gt;&lt;span&gt;kubectl delete pod pod名
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;查看镜像&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;color:#c0c5ce;&quot;&gt;&lt;code&gt;&lt;span&gt;crictl images
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
</content>
        
    </entry>
    <entry xml:lang="zh">
        <title>Docker 实践记录</title>
        <published>2022-10-06T14:47:19+00:00</published>
        <updated>2022-10-06T14:47:19+00:00</updated>
        <author>
          <name>Unknown</name>
        </author>
        <link rel="alternate" href="https://leaflare.github.io/202210061447/" type="text/html"/>
        <id>https://leaflare.github.io/202210061447/</id>
        
        <content type="html">&lt;span id=&quot;continue-reading&quot;&gt;&lt;&#x2F;span&gt;&lt;h2 id=&quot;dockerpei-zhi-wsl-integration&quot;&gt;Docker配置WSL Integration&lt;&#x2F;h2&gt;
&lt;p&gt;启动Docker Desktop&lt;&#x2F;p&gt;
&lt;p&gt;docker settings——&amp;gt;General——&amp;gt;勾选&lt;code&gt;Use the WSL 2 based engine&lt;&#x2F;code&gt; &lt;&#x2F;p&gt;
&lt;p&gt;docker settings——&amp;gt;Resources——&amp;gt;WSL Integration——&amp;gt;选择要启用的WSL 2 版本&lt;&#x2F;p&gt;
&lt;p&gt;如果已经安装配置过WSL却出现&lt;code&gt;You don’t have any WSL 2 distro. Please convert a WSL 1 distro to WSL 2&lt;&#x2F;code&gt;，解决方法如下：&lt;&#x2F;p&gt;
&lt;p&gt;使用命令检查WSL模式：&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;color:#c0c5ce;&quot;&gt;&lt;code&gt;&lt;span&gt;wsl.exe -l -v
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;将已存在的Linux发行版转到v2：&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;color:#c0c5ce;&quot;&gt;&lt;code&gt;&lt;span&gt;wsl.exe --set-version ubuntu 2
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;(Ubuntu是要启用的发行版本)&lt;&#x2F;p&gt;
&lt;p&gt;将 WSL 2 设置为默认版本：&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;color:#c0c5ce;&quot;&gt;&lt;code&gt;&lt;span&gt;wsl --set-default-version 2
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h3 id=&quot;chang-yong-su-cha&quot;&gt;常用速查：&lt;&#x2F;h3&gt;
&lt;ul&gt;
&lt;li&gt;列出计算机上的 docker 镜像：&lt;code&gt;docker image ls --all&lt;&#x2F;code&gt;&lt;&#x2F;li&gt;
&lt;li&gt;列出计算机上的容器：&lt;code&gt;docker container ls --all&lt;&#x2F;code&gt; 或 &lt;code&gt;docker ps -a&lt;&#x2F;code&gt;（如果没有 -a 显示全部标志，则仅显示正在运行的容器）&lt;&#x2F;li&gt;
&lt;li&gt;列出Docker 安装的系统信息，包括 WSL 2 上下文中你可使用的统计信息和资源（CPU &amp;amp; 内存）：&lt;code&gt;docker info&lt;&#x2F;code&gt;&lt;&#x2F;li&gt;
&lt;li&gt;运行镜像：&lt;code&gt;docker run --rm -it XXX&lt;&#x2F;code&gt;   --rm是指运行完了之后自动把容器删除，便于管理（X&lt;&#x2F;li&gt;
&lt;li&gt;删除镜像：&lt;code&gt;docker rmi XXX&lt;&#x2F;code&gt;&lt;&#x2F;li&gt;
&lt;li&gt;创建镜像：&lt;code&gt;docker build -t XXX .&lt;&#x2F;code&gt;  -t ：镜像的标签，注意最后的&lt;code&gt;‘.&#x27;&lt;&#x2F;code&gt;代表路径当前目录下，可替换其他path&lt;&#x2F;li&gt;
&lt;li&gt;将指定镜像保存成 tar 归档文件：&lt;code&gt;docker save -o XXX.tar XXX&lt;&#x2F;code&gt;      -o ：输出到的文件。&lt;&#x2F;li&gt;
&lt;li&gt;两组导入导出，不能混用：save 和 load，export 和 import。因为 import 和 export 导入导出的是一个容器的快照, 不是镜像本身。快照文件将丢弃所有的历史记录和元数据信息（即仅保存容器当时的快照状态），而镜像存储文件将保存完整记录，体积更大。docker save 保存的是镜像（image），docker export 保存的是容器（container），docker load 用来载入镜像包，docker import 用来载入容器包，但两者都会恢复为镜像&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
</content>
        
    </entry>
</feed>
