<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom" xml:lang="zh">
    <title>Fang Li - Java</title>
    <subtitle>Fang Li&#x27;s Blog</subtitle>
    <link href="https://ffangli.github.io/categories/java/atom.xml" rel="self" type="application/atom+xml"/>
    <link href="https://ffangli.github.io"/>
    <generator uri="https://www.getzola.org/">Zola</generator>
    <updated>2023-02-15T22:47:19+00:00</updated>
    <id>https://ffangli.github.io/categories/java/atom.xml</id>
    <entry xml:lang="zh">
        <title>vjvm note 02： Parser</title>
        <published>2023-02-15T22:47:19+00:00</published>
        <updated>2023-02-15T22:47:19+00:00</updated>
        <author>
          <name>Unknown</name>
        </author>
        <link rel="alternate" href="https://ffangli.github.io/202302152247/" type="text/html"/>
        <id>https://ffangli.github.io/202302152247/</id>
        <content type="html">&lt;span id=&quot;continue-reading&quot;&gt;&lt;&#x2F;span&gt;&lt;h2 id=&quot;class-wen-jian-jie-gou&quot;&gt;class 文件结构&lt;&#x2F;h2&gt;
&lt;pre data-lang=&quot;c&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-c &quot;&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;&lt;span&gt;ClassFile {
&lt;&#x2F;span&gt;&lt;span&gt;  u4              magic;
&lt;&#x2F;span&gt;&lt;span&gt;  u2              minor_version;
&lt;&#x2F;span&gt;&lt;span&gt;  u2              major_version;
&lt;&#x2F;span&gt;&lt;span&gt;  u2              constant_pool_count;
&lt;&#x2F;span&gt;&lt;span&gt;  cp_info         constant_pool[constant_pool_count - &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;]; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; 常量池
&lt;&#x2F;span&gt;&lt;span&gt;  u2              access_flags;
&lt;&#x2F;span&gt;&lt;span&gt;  u2              this_class;
&lt;&#x2F;span&gt;&lt;span&gt;  u2              super_class;
&lt;&#x2F;span&gt;&lt;span&gt;  u2              interfaces_count;
&lt;&#x2F;span&gt;&lt;span&gt;  u2              interfaces[interfaces_count]; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; 类实现的接口
&lt;&#x2F;span&gt;&lt;span&gt;  u2              fields_count;
&lt;&#x2F;span&gt;&lt;span&gt;  field_info      fields[fields_count]; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; 类的成员变量
&lt;&#x2F;span&gt;&lt;span&gt;  u2              methods_count;
&lt;&#x2F;span&gt;&lt;span&gt;  method_info     methods[methods_count]; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; 类的方法
&lt;&#x2F;span&gt;&lt;span&gt;  u2              attributes_count;
&lt;&#x2F;span&gt;&lt;span&gt;  attribute_info  attributes[attributes_count];
&lt;&#x2F;span&gt;&lt;span&gt;};
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;每一行的前一列是类型，后一列是名称。例如，&lt;code&gt;u4 magic&lt;&#x2F;code&gt; 代表 &lt;code&gt;magic&lt;&#x2F;code&gt; 为 32 位无符号整形。在一个 class 文件中，最重要的四个结构是常量池（Constant Pool）、 成员变量（Field）、方法（Method）和属性（Attribute）。&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;常量池（Constant Pool）这里的 &lt;code&gt;info&lt;&#x2F;code&gt; 成员的长度是可变的。&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;pre data-lang=&quot;c&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-c &quot;&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;&lt;span&gt;cp_info {
&lt;&#x2F;span&gt;&lt;span&gt;  u1  tag; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; 常量类型
&lt;&#x2F;span&gt;&lt;span&gt;  u1  info[]; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; 常量数据
&lt;&#x2F;span&gt;&lt;span&gt;};
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;比如，对于 &lt;code&gt;CONSTANT_Class_info&lt;&#x2F;code&gt;：&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;color:#c0c5ce;&quot;&gt;&lt;code&gt;&lt;span&gt;struct CONSTANT_Class_info {
&lt;&#x2F;span&gt;&lt;span&gt;  u1  tag;
&lt;&#x2F;span&gt;&lt;span&gt;  u2  name_index;
&lt;&#x2F;span&gt;&lt;span&gt;};
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;这里的 &lt;code&gt;info&lt;&#x2F;code&gt; 就被替换成了两个字节的索引，指向常量池中代表这个类名称的项。&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;成员变量（Field） 其中的 &lt;code&gt;name_index&lt;&#x2F;code&gt; 和 &lt;code&gt;descriptor_index&lt;&#x2F;code&gt; 都指向常量池的内容。&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;pre data-lang=&quot;c&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-c &quot;&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;&lt;span&gt;field_info {
&lt;&#x2F;span&gt;&lt;span&gt; u2 access_flags;
&lt;&#x2F;span&gt;&lt;span&gt; u2 name_index;
&lt;&#x2F;span&gt;&lt;span&gt; u2 descriptor_index;
&lt;&#x2F;span&gt;&lt;span&gt; u2 attributes_count;
&lt;&#x2F;span&gt;&lt;span&gt; attribute_info attributes[attributes_count];
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;ul&gt;
&lt;li&gt;方法（Method）&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;pre data-lang=&quot;c&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-c &quot;&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;&lt;span&gt;method_info {
&lt;&#x2F;span&gt;&lt;span&gt; u2 access_flags;
&lt;&#x2F;span&gt;&lt;span&gt; u2 name_index;
&lt;&#x2F;span&gt;&lt;span&gt; u2 descriptor_index;
&lt;&#x2F;span&gt;&lt;span&gt; u2 attributes_count;
&lt;&#x2F;span&gt;&lt;span&gt; attribute_info attributes[attributes_count];
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;ul&gt;
&lt;li&gt;属性（Attribute）属性在类、成员变量和方法的结构中出现，一个属性的通用结构如下：&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;pre style=&quot;background-color:#2b303b;color:#c0c5ce;&quot;&gt;&lt;code&gt;&lt;span&gt;attribute_info {
&lt;&#x2F;span&gt;&lt;span&gt; u2 attribute_name_index;
&lt;&#x2F;span&gt;&lt;span&gt; u4 attribute_length;
&lt;&#x2F;span&gt;&lt;span&gt; u1 info[attribute_length];
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;属性中保存了许多内容，如 &lt;code&gt;static final&lt;&#x2F;code&gt; 变量的值、方法的代码、异常处理所需的信息等。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;duo-xing-qiu-zhi-he-ji-zao-qiu-zhi&quot;&gt;惰性求值和及早求值&lt;&#x2F;h2&gt;
&lt;p&gt;惰性求值（Lazy Evaluation）在需要时才进行计算&lt;&#x2F;p&gt;
&lt;p&gt;及早求值  (Eager Evaluation) 在构造时就把全部值计算出来&lt;&#x2F;p&gt;
&lt;h2 id=&quot;dai-ma&quot;&gt;代码&lt;&#x2F;h2&gt;
&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;ffangli&#x2F;toyjvm&quot;&gt;ffangli&#x2F;toyjvm (github.com)&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;color:#c0c5ce;&quot;&gt;&lt;code&gt;&lt;span&gt;$ tree src&#x2F;main&#x2F;java&#x2F;vjvm&#x2F;classfiledefs
&lt;&#x2F;span&gt;&lt;span&gt;$ tree src&#x2F;main&#x2F;java&#x2F;vjvm&#x2F;runtime&#x2F;classdata
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h2 id=&quot;can-kao-wen-xian&quot;&gt;参考文献&lt;&#x2F;h2&gt;
&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;docs.oracle.com&#x2F;javase&#x2F;specs&#x2F;jvms&#x2F;se8&#x2F;jvms8.pdf&quot;&gt;The Java® Virtual Machine Specification (oracle.com)&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
</content>
    </entry>
    <entry xml:lang="zh">
        <title>vjvm note 01： ClassLoader</title>
        <published>2023-02-13T20:47:19+00:00</published>
        <updated>2023-02-13T20:47:19+00:00</updated>
        <author>
          <name>Unknown</name>
        </author>
        <link rel="alternate" href="https://ffangli.github.io/202302132047/" type="text/html"/>
        <id>https://ffangli.github.io/202302132047/</id>
        <content type="html">&lt;span id=&quot;continue-reading&quot;&gt;&lt;&#x2F;span&gt;&lt;h2 id=&quot;classloader&quot;&gt;ClassLoader&lt;&#x2F;h2&gt;
&lt;p&gt;作为Java运行时环境的一部分，Java ClassLoader动态地将Java类加载到Java虚拟机中。通过在Java中使用类加载器，它不需要Java运行时系统了解文件和文件系统的情况。Java类在应用程序需要时被加载，而不是一次性加载到内存中。Java中的ClassLoader是由JRE调用的。这些ClassLoaders动态地将类加载到内存中。&lt;&#x2F;p&gt;
&lt;p&gt;在java中，有以下3种默认的类加载器:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Bootstrap ClassLoader:&lt;&#x2F;strong&gt; Loads class from JRE&#x2F;lib&#x2F;rt.jar&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;Extension ClassLoader:&lt;&#x2F;strong&gt; Loads class from JRE&#x2F;lib&#x2F;ext&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;Application ClassLoader:&lt;&#x2F;strong&gt; Loads class from CLASSPATH environment variable&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h2 id=&quot;shuang-qin-wei-tuo-jia-zai-ji-zhi-parent-first&quot;&gt;双亲委托加载机制（Parent-First）&lt;&#x2F;h2&gt;
&lt;p&gt;ClassLoader委托层次模型的运作顺序是:&lt;&#x2F;p&gt;
&lt;p&gt;Application ClassLoader -&amp;gt; Extension ClassLoader -&amp;gt; Bootstrap ClassLoader&lt;&#x2F;p&gt;
&lt;p&gt;Java 默认使用了名为 parent-first 的策略：每个 loader（除 Bootstrap Loader 外）均有一个&lt;strong&gt;亲代加载器 （parent）&lt;&#x2F;strong&gt;，在搜索 class 时首先委托亲代进行搜索，找不到时才搜索自己的加载路径。 于是，各个 ClassLoader 之间就形成了如下的委托关系：&lt;&#x2F;p&gt;
&lt;img src=&quot;.\img\loader-hierarchy.png&quot; style=&quot;zoom:80%;&quot; &#x2F;&gt;
&lt;pre style=&quot;background-color:#2b303b;color:#c0c5ce;&quot;&gt;&lt;code&gt;&lt;span&gt;if 需要加载的 class 已被保存在 definedClass 中：
&lt;&#x2F;span&gt;&lt;span&gt;    返回已加载的 class
&lt;&#x2F;span&gt;&lt;span&gt;else if parent 不为 null：
&lt;&#x2F;span&gt;&lt;span&gt;    使用 parent 加载 class
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;if parent 未找到相应的 class：
&lt;&#x2F;span&gt;&lt;span&gt;    for searchPaths 中的每一项：
&lt;&#x2F;span&gt;&lt;span&gt;        尝试使用它来加载类，并调用 JClass 构造函数构造类
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;if 所有的 searchPath 都没有找到需要加载的类：
&lt;&#x2F;span&gt;&lt;span&gt;    返回 null
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;在查找 class 文件时，一个 loader 可能会搜索以下两种路径：&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;搜索单个目录&lt;&#x2F;p&gt;
&lt;p&gt;在指定 &lt;code&gt;&#x2F;foo&lt;&#x2F;code&gt; 为加载路径时，如果加载 &lt;code&gt;bar.A&lt;&#x2F;code&gt; 类，你应该查找 &lt;code&gt;&#x2F;foo&#x2F;bar&#x2F;A.class&lt;&#x2F;code&gt; 文件。&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;单个 Jar 文件&lt;&#x2F;p&gt;
&lt;p&gt;Jar 文件事实上是一个 zip 压缩包，将多个 class 文件打包在一起。在从 &lt;code&gt;&#x2F;foo&#x2F;bar.jar&lt;&#x2F;code&gt; 中加载 &lt;code&gt;baz.B&lt;&#x2F;code&gt; 时，你应该读取该文件并搜索其中的 &lt;code&gt;baz&#x2F;B.class&lt;&#x2F;code&gt;路径。JDK 中提供了 &lt;code&gt;JarFile&lt;&#x2F;code&gt; 类来读取 jar 文件。（可以使用 &lt;code&gt;jar -tf &amp;lt;jarfile&amp;gt;&lt;&#x2F;code&gt; 查看 Jar 文件的内容）&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;h2 id=&quot;dai-ma&quot;&gt;代码&lt;&#x2F;h2&gt;
&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;ffangli&#x2F;toyjvm&quot;&gt;ffangli&#x2F;toyjvm (github.com)&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;color:#c0c5ce;&quot;&gt;&lt;code&gt;&lt;span&gt;$ tree src&#x2F;main&#x2F;java&#x2F;vjvm&#x2F;classloader
&lt;&#x2F;span&gt;&lt;span&gt;src&#x2F;main&#x2F;java&#x2F;vjvm&#x2F;classloader
&lt;&#x2F;span&gt;&lt;span&gt;├── searchpath
&lt;&#x2F;span&gt;&lt;span&gt;│   └── ClassSearchPath.java
&lt;&#x2F;span&gt;&lt;span&gt;        DirSearchPath.java
&lt;&#x2F;span&gt;&lt;span&gt;        JarSearchPath.java
&lt;&#x2F;span&gt;&lt;span&gt;        ModuleSearchPath.java
&lt;&#x2F;span&gt;&lt;span&gt;└──JClassLoader.java
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
</content>
    </entry>
    <entry xml:lang="zh">
        <title>Java版本问题处理合集</title>
        <published>2021-11-12T16:13:14+00:00</published>
        <updated>2021-11-12T16:13:14+00:00</updated>
        <author>
          <name>Unknown</name>
        </author>
        <link rel="alternate" href="https://ffangli.github.io/202111121613/" type="text/html"/>
        <id>https://ffangli.github.io/202111121613/</id>
        <content type="html">&lt;span id=&quot;continue-reading&quot;&gt;&lt;&#x2F;span&gt;
&lt;h2 id=&quot;bu-yi-zhi-bao-cuo&quot;&gt;不一致报错&lt;&#x2F;h2&gt;
&lt;h3 id=&quot;a-jni-error-has-occurred-please-check-your-installation-and-try-again&quot;&gt;A JNI error has occurred, please check your installation and try again&lt;&#x2F;h3&gt;
&lt;p&gt;javac与java版本不同所致&lt;&#x2F;p&gt;
&lt;p&gt;检查&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;color:#c0c5ce;&quot;&gt;&lt;code&gt;&lt;span&gt;javac -version
&lt;&#x2F;span&gt;&lt;span&gt;java -version
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;在环境变量Path变量中将需要使用的路径上移，例如将&lt;code&gt;%JAVA_HOME%\bin&lt;&#x2F;code&gt;路径移至&lt;code&gt;C:\Program Files (x86)\Common Files\Oracle\Java\javapath&lt;&#x2F;code&gt;之上&lt;&#x2F;p&gt;
&lt;p&gt;这个时候在idea运行之前的项目还是会有报错，需要手动换SDK&lt;&#x2F;p&gt;
</content>
    </entry>
</feed>
