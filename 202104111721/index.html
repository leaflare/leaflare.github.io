<!DOCTYPE html>
<html lang="en">
    <head>
      <meta http-equiv="X-UA-Compatible" content="IE=edge">
      <meta http-equiv="content-type" content="text/html; charset=utf-8">

      <!-- Enable responsiveness on mobile devices-->
      <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">

      <title>Arceus - Dp template</title>

      

      
          <script src="https://cdnjs.cloudflare.com/ajax/libs/slideout/1.0.1/slideout.min.js"></script>
          
      

      
          <link rel="stylesheet" href="https://arceusj2000.github.io/site.css">
          
      

      
      
    </head>

    <body>
        <div class="container">

            <div id="mobile-navbar" class="mobile-navbar">
              <div class="mobile-header-logo">
                <a href="/" class="logo">Arceus</a>
              </div>
              <div class="mobile-navbar-icon icon-out">
                <span></span>
                <span></span>
                <span></span>
              </div>
            </div>

            <nav id="mobile-menu" class="mobile-menu slideout-menu slideout-menu-left">
              <ul class="mobile-menu-list">
                
                    <li class="mobile-menu-item">
                        <a href="https:&#x2F;&#x2F;arceusj2000.github.io">
                            主页
                        </a>
                    </li>
                
                    <li class="mobile-menu-item">
                        <a href="https:&#x2F;&#x2F;arceusj2000.github.io&#x2F;categories">
                            分类
                        </a>
                    </li>
                
                    <li class="mobile-menu-item">
                        <a href="https:&#x2F;&#x2F;arceusj2000.github.io&#x2F;tags">
                            标签
                        </a>
                    </li>
                
                    <li class="mobile-menu-item">
                        <a href="https:&#x2F;&#x2F;github.com&#x2F;arceusj2000">
                            GitHub
                        </a>
                    </li>
                
              </ul>
            </nav>

            <header id="header">
                <div class="logo"><a href="https:&#x2F;&#x2F;arceusj2000.github.io">Arceus</a></div>
                <nav class="menu">
                    <ul>
                        
                            <li>
                                <a href="https:&#x2F;&#x2F;arceusj2000.github.io">
                                    主页
                                </a>
                            </li>
                        
                            <li>
                                <a href="https:&#x2F;&#x2F;arceusj2000.github.io&#x2F;categories">
                                    分类
                                </a>
                            </li>
                        
                            <li>
                                <a href="https:&#x2F;&#x2F;arceusj2000.github.io&#x2F;tags">
                                    标签
                                </a>
                            </li>
                        
                            <li>
                                <a href="https:&#x2F;&#x2F;github.com&#x2F;arceusj2000">
                                    GitHub
                                </a>
                            </li>
                        
                    </ul>
                </nav>
            </header>

            <main>
                <div class="content" id="mobile-panel">
                    


<div class="post-toc" id="post-toc">
    <h2 class="post-toc-title">Contents</h2>
    <div class="post-toc-content always-active">
        <nav id="TableOfContents">
            <ul>
                
                <li>
                    <a href="https://arceusj2000.github.io/202104111721/#fei-bo-na-qi-shu-lie" class="toc-link">斐波那契数列</a>
                    
                    <ul>
                        
                        <li>
                            <a href="https://arceusj2000.github.io/202104111721/#bao-li-di-gui" class="toc-link">暴力递归</a>
                        </li>
                        
                        <li>
                            <a href="https://arceusj2000.github.io/202104111721/#dai-bei-wang-lu-de-di-gui-jie-fa" class="toc-link">带备忘录的递归解法</a>
                        </li>
                        
                        <li>
                            <a href="https://arceusj2000.github.io/202104111721/#dp-shu-zu-de-die-dai-jie-fa" class="toc-link">dp 数组的迭代解法</a>
                        </li>
                        
                        <li>
                            <a href="https://arceusj2000.github.io/202104111721/#kong-jian-fu-za-du-jiang-wei-o-1" class="toc-link">空间复杂度降为 O(1)</a>
                        </li>
                        
                    </ul>
                    
                </li>
                
                <li>
                    <a href="https://arceusj2000.github.io/202104111721/#cou-ling-qian-wen-ti" class="toc-link">凑零钱问题</a>
                    
                    <ul>
                        
                        <li>
                            <a href="https://arceusj2000.github.io/202104111721/#ti-mu" class="toc-link">题目</a>
                        </li>
                        
                        <li>
                            <a href="https://arceusj2000.github.io/202104111721/#si-lu" class="toc-link">思路</a>
                        </li>
                        
                        <li>
                            <a href="https://arceusj2000.github.io/202104111721/#bao-li-jie-fa" class="toc-link">暴力解法</a>
                        </li>
                        
                        <li>
                            <a href="https://arceusj2000.github.io/202104111721/#dai-bei-wang-lu-de-di-gui" class="toc-link">带备忘录的递归</a>
                        </li>
                        
                        <li>
                            <a href="https://arceusj2000.github.io/202104111721/#dp-shu-zu-de-die-dai-jie-fa-1" class="toc-link">dp 数组的迭代解法</a>
                        </li>
                        
                    </ul>
                    
                </li>
                
            </ul>
        </nav>
    </div>
</div>


<article class="post">
    
    <header class="post__header">
        <h1 class="post__title">
            <a href="https:&#x2F;&#x2F;arceusj2000.github.io&#x2F;202104111721&#x2F;">Dp template</a>
        </h1>
        <div class="post__meta">
            <span class="post__time">2021-04-11</span>
            
        </div>
    </header>

    <div class="post-content">
      <p>动态规划</p>
<span id="continue-reading"></span>
<p>动态规划问题的一般形式是穷举求最值，比如最长递增子序列，最小距离。</p>
<p><strong>存在「重叠子问题」</strong>：如果暴力穷举效率会极其低下，所以需要「备忘录」或者「DP table」来优化穷举过程，避<strong>存在「最优子结构」</strong>：才能通过子问题的最值得到原问题的最值。</p>
<p><strong>找到「状态」 -&gt; 定义 dp 数组/函数 -&gt; 明确「选择」-&gt; 明确 base case。</strong></p>
<h2 id="fei-bo-na-qi-shu-lie">斐波那契数列</h2>
<h3 id="bao-li-di-gui">暴力递归</h3>
<pre data-lang="c++" style="background-color:#2b303b;color:#c0c5ce;" class="language-c++ "><code class="language-c++" data-lang="c++"><span style="color:#b48ead;">int </span><span style="color:#8fa1b3;">fib</span><span>(</span><span style="color:#b48ead;">int </span><span style="color:#bf616a;">N</span><span>) {
</span><span>    </span><span style="color:#b48ead;">if </span><span>(N == </span><span style="color:#d08770;">1 </span><span>|| N == </span><span style="color:#d08770;">2</span><span>) </span><span style="color:#b48ead;">return </span><span style="color:#d08770;">1</span><span>;
</span><span>    </span><span style="color:#b48ead;">return </span><span style="color:#bf616a;">fib</span><span>(N - </span><span style="color:#d08770;">1</span><span>) + </span><span style="color:#bf616a;">fib</span><span>(N - </span><span style="color:#d08770;">2</span><span>);
</span><span>}
</span></code></pre>
<p>时间复杂度： O(2^n)</p>
<h3 id="dai-bei-wang-lu-de-di-gui-jie-fa">带备忘录的递归解法</h3>
<pre data-lang="c++" style="background-color:#2b303b;color:#c0c5ce;" class="language-c++ "><code class="language-c++" data-lang="c++"><span style="color:#b48ead;">int </span><span style="color:#8fa1b3;">fib</span><span>(</span><span style="color:#b48ead;">int </span><span style="color:#bf616a;">N</span><span>) {
</span><span>    </span><span style="color:#b48ead;">if </span><span>(N &lt; </span><span style="color:#d08770;">1</span><span>) </span><span style="color:#b48ead;">return </span><span style="color:#d08770;">0</span><span>;
</span><span>    </span><span style="color:#65737e;">// 备忘录全初始化为 0
</span><span>    vector&lt;</span><span style="color:#b48ead;">int</span><span>&gt; </span><span style="color:#bf616a;">memo</span><span>(N + </span><span style="color:#d08770;">1</span><span>, </span><span style="color:#d08770;">0</span><span>);
</span><span>    </span><span style="color:#65737e;">// 初始化最简情况
</span><span>    </span><span style="color:#b48ead;">return </span><span style="color:#bf616a;">helper</span><span>(memo, N);
</span><span>}
</span><span>
</span><span style="color:#b48ead;">int </span><span style="color:#8fa1b3;">helper</span><span>(vector&lt;</span><span style="color:#b48ead;">int</span><span>&gt;&amp; </span><span style="color:#bf616a;">memo</span><span>, </span><span style="color:#b48ead;">int </span><span style="color:#bf616a;">n</span><span>) {
</span><span>    </span><span style="color:#65737e;">// base case 
</span><span>    </span><span style="color:#b48ead;">if </span><span>(n == </span><span style="color:#d08770;">1 </span><span>|| n == </span><span style="color:#d08770;">2</span><span>) </span><span style="color:#b48ead;">return </span><span style="color:#d08770;">1</span><span>;
</span><span>    </span><span style="color:#65737e;">// 已经计算过
</span><span>    </span><span style="color:#b48ead;">if </span><span>(memo[n] != </span><span style="color:#d08770;">0</span><span>) </span><span style="color:#b48ead;">return</span><span> memo[n];
</span><span>    memo[n] = </span><span style="color:#bf616a;">helper</span><span>(memo, n - </span><span style="color:#d08770;">1</span><span>) + 
</span><span>                </span><span style="color:#bf616a;">helper</span><span>(memo, n - </span><span style="color:#d08770;">2</span><span>);
</span><span>    </span><span style="color:#b48ead;">return</span><span> memo[n];
</span><span>}
</span></code></pre>
<p>时间复杂度： O(n)</p>
<h3 id="dp-shu-zu-de-die-dai-jie-fa">dp 数组的迭代解法</h3>
<pre data-lang="c++" style="background-color:#2b303b;color:#c0c5ce;" class="language-c++ "><code class="language-c++" data-lang="c++"><span style="color:#b48ead;">int </span><span style="color:#8fa1b3;">fib</span><span>(</span><span style="color:#b48ead;">int </span><span style="color:#bf616a;">N</span><span>) {
</span><span>    vector&lt;</span><span style="color:#b48ead;">int</span><span>&gt; </span><span style="color:#bf616a;">dp</span><span>(N + </span><span style="color:#d08770;">1</span><span>, </span><span style="color:#d08770;">0</span><span>);
</span><span>    </span><span style="color:#65737e;">// base case
</span><span>    dp[</span><span style="color:#d08770;">1</span><span>] = dp[</span><span style="color:#d08770;">2</span><span>] = </span><span style="color:#d08770;">1</span><span>;
</span><span>    </span><span style="color:#b48ead;">for </span><span>(</span><span style="color:#b48ead;">int</span><span> i = </span><span style="color:#d08770;">3</span><span>; i &lt;= N; i++)
</span><span>        dp[i] = dp[i - </span><span style="color:#d08770;">1</span><span>] + dp[i - </span><span style="color:#d08770;">2</span><span>];
</span><span>    </span><span style="color:#b48ead;">return</span><span> dp[N];
</span><span>}
</span></code></pre>
<p>时间复杂度： O(n)</p>
<h3 id="kong-jian-fu-za-du-jiang-wei-o-1">空间复杂度降为 O(1)</h3>
<p>根据斐波那契数列的状态转移方程，当前状态只和之前的两个状态有关，只要存储之前的两个状态就可以了。</p>
<pre data-lang="c++" style="background-color:#2b303b;color:#c0c5ce;" class="language-c++ "><code class="language-c++" data-lang="c++"><span style="color:#b48ead;">int </span><span style="color:#8fa1b3;">fib</span><span>(</span><span style="color:#b48ead;">int </span><span style="color:#bf616a;">n</span><span>) {
</span><span>    </span><span style="color:#b48ead;">if </span><span>(n == </span><span style="color:#d08770;">2 </span><span>|| n == </span><span style="color:#d08770;">1</span><span>) 
</span><span>        </span><span style="color:#b48ead;">return </span><span style="color:#d08770;">1</span><span>;
</span><span>    </span><span style="color:#b48ead;">int</span><span> prev = </span><span style="color:#d08770;">1</span><span>, curr = </span><span style="color:#d08770;">1</span><span>;
</span><span>    </span><span style="color:#b48ead;">for </span><span>(</span><span style="color:#b48ead;">int</span><span> i = </span><span style="color:#d08770;">3</span><span>; i &lt;= n; i++) {
</span><span>        </span><span style="color:#b48ead;">int</span><span> sum = prev + curr;
</span><span>        prev = curr;
</span><span>        curr = sum;
</span><span>    }
</span><span>    </span><span style="color:#b48ead;">return</span><span> curr;
</span><span>}
</span></code></pre>
<h2 id="cou-ling-qian-wen-ti">凑零钱问题</h2>
<h4 id="ti-mu">题目</h4>
<p><code>k</code>种面值的硬币，面值分别为<code>c1, c2 ... ck</code>，每种硬币的数量无限，再给一个总金额<code>amount</code>，问最少需要几枚硬币凑出这个金额，如果不可能凑出，算法返回 -1 。</p>
<h4 id="si-lu">思路</h4>
<p><strong>「状态」</strong>：目标金额<code>amount</code>。</p>
<p><strong><code>dp</code>函数的定义</strong>：函数 dp(n)表示，当前的目标金额是<code>n</code>，至少需要<code>dp(n)</code>个硬币凑出该金额。</p>
<p><strong>「选择」并择优</strong>，也就是对于每个状态，可以做出什么选择改变当前状态。具体到这个问题，无论当的目标金额是多少，选择就是从面额列表<code>coins</code>中选择一个硬币，然后目标金额就会减少</p>
<p><strong>base case</strong>，目标金额为 0 时，所需硬币数量为 0；当目标金额小于 0 时，无解，返回 -1</p>
<h3 id="bao-li-jie-fa">暴力解法</h3>
<pre data-lang="python" style="background-color:#2b303b;color:#c0c5ce;" class="language-python "><code class="language-python" data-lang="python"><span style="color:#65737e;"># 伪码框架
</span><span style="color:#b48ead;">def </span><span style="color:#8fa1b3;">coinChange</span><span>(</span><span style="color:#bf616a;">coins</span><span>: List[int], </span><span style="color:#bf616a;">amount</span><span>: int):
</span><span>    </span><span style="color:#65737e;"># 定义：要凑出金额 n，至少要 dp(n) 个硬币
</span><span>    </span><span style="color:#b48ead;">def </span><span style="color:#8fa1b3;">dp</span><span>(</span><span style="color:#bf616a;">n</span><span>):
</span><span>        </span><span style="color:#65737e;"># 做选择，需要硬币最少的那个结果就是答案
</span><span>        </span><span style="color:#b48ead;">for </span><span>coin </span><span style="color:#b48ead;">in </span><span>coins:
</span><span>            res = </span><span style="color:#96b5b4;">min</span><span>(res, </span><span style="color:#d08770;">1 </span><span>+ </span><span style="color:#bf616a;">dp</span><span>(n - coin))
</span><span>        </span><span style="color:#b48ead;">return </span><span>res
</span><span>    </span><span style="color:#65737e;"># 我们要求目标金额是 amount
</span><span>    </span><span style="color:#b48ead;">return </span><span style="color:#bf616a;">dp</span><span>(amount)
</span><span>
</span></code></pre>
<pre data-lang="python" style="background-color:#2b303b;color:#c0c5ce;" class="language-python "><code class="language-python" data-lang="python"><span style="color:#b48ead;">def </span><span style="color:#8fa1b3;">coinChange</span><span>(</span><span style="color:#bf616a;">coins</span><span>: List[int], </span><span style="color:#bf616a;">amount</span><span>: int):
</span><span>
</span><span>    </span><span style="color:#b48ead;">def </span><span style="color:#8fa1b3;">dp</span><span>(</span><span style="color:#bf616a;">n</span><span>):
</span><span>        </span><span style="color:#65737e;"># base case
</span><span>        </span><span style="color:#b48ead;">if </span><span>n == </span><span style="color:#d08770;">0</span><span>: </span><span style="color:#b48ead;">return </span><span style="color:#d08770;">0
</span><span>        </span><span style="color:#b48ead;">if </span><span>n &lt; </span><span style="color:#d08770;">0</span><span>: </span><span style="color:#b48ead;">return </span><span>-</span><span style="color:#d08770;">1
</span><span>        </span><span style="color:#65737e;"># 求最小值，所以初始化为正无穷
</span><span>        res = </span><span style="color:#bf616a;">float</span><span>(&#39;</span><span style="color:#a3be8c;">INF</span><span>&#39;)
</span><span>        </span><span style="color:#b48ead;">for </span><span>coin </span><span style="color:#b48ead;">in </span><span>coins:
</span><span>            subproblem = </span><span style="color:#bf616a;">dp</span><span>(n - coin)
</span><span>            </span><span style="color:#65737e;"># 子问题无解，跳过
</span><span>            </span><span style="color:#b48ead;">if </span><span>subproblem == -</span><span style="color:#d08770;">1</span><span>: </span><span style="color:#b48ead;">continue
</span><span>            res = </span><span style="color:#96b5b4;">min</span><span>(res, </span><span style="color:#d08770;">1 </span><span>+ subproblem)
</span><span>
</span><span>        </span><span style="color:#b48ead;">return </span><span>res </span><span style="color:#b48ead;">if </span><span>res != </span><span style="color:#bf616a;">float</span><span>(&#39;</span><span style="color:#a3be8c;">INF</span><span>&#39;) </span><span style="color:#b48ead;">else </span><span>-</span><span style="color:#d08770;">1
</span><span>
</span><span>    </span><span style="color:#b48ead;">return </span><span style="color:#bf616a;">dp</span><span>(amount)
</span></code></pre>
<p><strong>时间复杂度：子问题总数 x 解决每个子问题的时间</strong>。</p>
<p>子问题总数为递归树节点个数，是 O(n^k)。每个子问题中含有一个 for 循环，复杂度为 O(k)。所以总时间复杂度为 O(k * n^k)，指数级别。</p>
<h3 id="dai-bei-wang-lu-de-di-gui">带备忘录的递归</h3>
<p>通过备忘录消除子问题</p>
<pre data-lang="python" style="background-color:#2b303b;color:#c0c5ce;" class="language-python "><code class="language-python" data-lang="python"><span style="color:#b48ead;">def </span><span style="color:#8fa1b3;">coinChange</span><span>(</span><span style="color:#bf616a;">coins</span><span>: List[int], </span><span style="color:#bf616a;">amount</span><span>: int):
</span><span>    </span><span style="color:#65737e;"># 备忘录
</span><span>    memo = </span><span style="color:#bf616a;">dict</span><span>()
</span><span>    </span><span style="color:#b48ead;">def </span><span style="color:#8fa1b3;">dp</span><span>(</span><span style="color:#bf616a;">n</span><span>):
</span><span>        </span><span style="color:#65737e;"># 查备忘录，避免重复计算
</span><span>        </span><span style="color:#b48ead;">if </span><span>n in memo: </span><span style="color:#b48ead;">return </span><span>memo[n]
</span><span>
</span><span>        </span><span style="color:#b48ead;">if </span><span>n == </span><span style="color:#d08770;">0</span><span>: </span><span style="color:#b48ead;">return </span><span style="color:#d08770;">0
</span><span>        </span><span style="color:#b48ead;">if </span><span>n &lt; </span><span style="color:#d08770;">0</span><span>: </span><span style="color:#b48ead;">return </span><span>-</span><span style="color:#d08770;">1
</span><span>        res = </span><span style="color:#bf616a;">float</span><span>(&#39;</span><span style="color:#a3be8c;">INF</span><span>&#39;)
</span><span>        </span><span style="color:#b48ead;">for </span><span>coin </span><span style="color:#b48ead;">in </span><span>coins:
</span><span>            subproblem = </span><span style="color:#bf616a;">dp</span><span>(n - coin)
</span><span>            </span><span style="color:#b48ead;">if </span><span>subproblem == -</span><span style="color:#d08770;">1</span><span>: </span><span style="color:#b48ead;">continue
</span><span>            res = </span><span style="color:#96b5b4;">min</span><span>(res, </span><span style="color:#d08770;">1 </span><span>+ subproblem)
</span><span>
</span><span>        </span><span style="color:#65737e;"># 记入备忘录
</span><span>        memo[n] = res </span><span style="color:#b48ead;">if </span><span>res != </span><span style="color:#bf616a;">float</span><span>(&#39;</span><span style="color:#a3be8c;">INF</span><span>&#39;) </span><span style="color:#b48ead;">else </span><span>-</span><span style="color:#d08770;">1
</span><span>        </span><span style="color:#b48ead;">return </span><span>memo[n]
</span><span>
</span><span>    </span><span style="color:#b48ead;">return </span><span style="color:#bf616a;">dp</span><span>(amount)
</span></code></pre>
<p>子问题总数不会超过金额数 n，即子问题数目为 O(n)。处理一个子问题的时间不变，仍是 O(k)，所以总的时间复杂度是 O(kn)。</p>
<h3 id="dp-shu-zu-de-die-dai-jie-fa-1">dp 数组的迭代解法</h3>
<p><code>dp[i] = x</code>表示，当目标金额为<code>i</code>时，至少需要<code>x</code>枚硬币。</p>
<pre data-lang="c++" style="background-color:#2b303b;color:#c0c5ce;" class="language-c++ "><code class="language-c++" data-lang="c++"><span style="color:#b48ead;">int </span><span style="color:#8fa1b3;">coinChange</span><span>(vector&lt;</span><span style="color:#b48ead;">int</span><span>&gt;&amp; </span><span style="color:#bf616a;">coins</span><span>, </span><span style="color:#b48ead;">int </span><span style="color:#bf616a;">amount</span><span>) {
</span><span>    </span><span style="color:#65737e;">// 数组大小为 amount + 1，初始值也为 amount + 1
</span><span>    vector&lt;</span><span style="color:#b48ead;">int</span><span>&gt; </span><span style="color:#bf616a;">dp</span><span>(amount + </span><span style="color:#d08770;">1</span><span>, amount + </span><span style="color:#d08770;">1</span><span>);
</span><span>    </span><span style="color:#65737e;">// base case
</span><span>    dp[</span><span style="color:#d08770;">0</span><span>] = </span><span style="color:#d08770;">0</span><span>;
</span><span>    </span><span style="color:#b48ead;">for </span><span>(</span><span style="color:#b48ead;">int</span><span> i = </span><span style="color:#d08770;">0</span><span>; i &lt; dp.</span><span style="color:#bf616a;">size</span><span>(); i++) {
</span><span>        </span><span style="color:#65737e;">// 内层 for 在求所有子问题 + 1 的最小值
</span><span>        </span><span style="color:#b48ead;">for </span><span>(</span><span style="color:#b48ead;">int</span><span> coin : coins) {
</span><span>            </span><span style="color:#65737e;">// 子问题无解，跳过
</span><span>            </span><span style="color:#b48ead;">if </span><span>(i - coin &lt; </span><span style="color:#d08770;">0</span><span>) </span><span style="color:#b48ead;">continue</span><span>;
</span><span>            dp[i] = </span><span style="color:#bf616a;">min</span><span>(dp[i], </span><span style="color:#d08770;">1 </span><span>+ dp[i - coin]);
</span><span>        }
</span><span>    }
</span><span>    </span><span style="color:#b48ead;">return </span><span>(dp[amount] == amount + </span><span style="color:#d08770;">1</span><span>) ? -</span><span style="color:#d08770;">1 </span><span>: dp[amount];
</span><span>}
</span></code></pre>
<p><code>dp</code>数组初始化为<code>amount + 1</code>，是因为凑成<code>amount</code>金额的硬币数最多只可能等于<code>amount</code>（全用 1 元面值的硬币），所以初始化为<code>amount + 1</code>就相当于初始化为正无穷，便于后续取最小值。</p>

    </div>

    
    

    <div class="post-footer">
        
            
                <div class="post-tags">
                    
                        <a href="https://arceusj2000.github.io/tags/cram/">#Cram</a>
                    
                </div>
            
            

        

    </div>

    
    
</article>


                </div>
            </main>

            
            
        </div>

      
          <script type="text/javascript" src="https://arceusj2000.github.io/even.js" ></script>
      
    </body>

</html>
