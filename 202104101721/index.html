<!DOCTYPE html>
<html lang="en">
    <head>
      <meta http-equiv="X-UA-Compatible" content="IE=edge">
      <meta http-equiv="content-type" content="text/html; charset=utf-8">

      <!-- Enable responsiveness on mobile devices-->
      <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">

      <title>Fang Li - Data structure template</title>

      

      
          <script src="https://cdnjs.cloudflare.com/ajax/libs/slideout/1.0.1/slideout.min.js"></script>
          
      

      
          <link rel="stylesheet" href="https://ffangl.github.io/site.css">
          
      

      
      
    </head>

    <body>
        <div class="container">

            <div id="mobile-navbar" class="mobile-navbar">
              <div class="mobile-header-logo">
                <a href="/" class="logo">Fang L</a>
              </div>
              <div class="mobile-navbar-icon icon-out">
                <span></span>
                <span></span>
                <span></span>
              </div>
            </div>

            <nav id="mobile-menu" class="mobile-menu slideout-menu slideout-menu-left">
              <ul class="mobile-menu-list">
                
                    <li class="mobile-menu-item">
                        <a href="https:&#x2F;&#x2F;ffangl.github.io">
                            主页
                        </a>
                    </li>
                
                    <li class="mobile-menu-item">
                        <a href="https:&#x2F;&#x2F;ffangl.github.io&#x2F;categories">
                            分类
                        </a>
                    </li>
                
                    <li class="mobile-menu-item">
                        <a href="https:&#x2F;&#x2F;ffangl.github.io&#x2F;tags">
                            标签
                        </a>
                    </li>
                
                    <li class="mobile-menu-item">
                        <a href="https:&#x2F;&#x2F;github.com&#x2F;ffangl">
                            GitHub
                        </a>
                    </li>
                
              </ul>
            </nav>

            <header id="header">
                <div class="logo"><a href="https:&#x2F;&#x2F;ffangl.github.io">Fang L</a></div>
                <nav class="menu">
                    <ul>
                        
                            <li>
                                <a href="https:&#x2F;&#x2F;ffangl.github.io">
                                    主页
                                </a>
                            </li>
                        
                            <li>
                                <a href="https:&#x2F;&#x2F;ffangl.github.io&#x2F;categories">
                                    分类
                                </a>
                            </li>
                        
                            <li>
                                <a href="https:&#x2F;&#x2F;ffangl.github.io&#x2F;tags">
                                    标签
                                </a>
                            </li>
                        
                            <li>
                                <a href="https:&#x2F;&#x2F;github.com&#x2F;ffangl">
                                    GitHub
                                </a>
                            </li>
                        
                    </ul>
                </nav>
            </header>

            <main>
                <div class="content" id="mobile-panel">
                    


<div class="post-toc" id="post-toc">
    <h2 class="post-toc-title">Contents</h2>
    <div class="post-toc-content always-active">
        <nav id="TableOfContents">
            <ul>
                
                <li>
                    <a href="https://ffangl.github.io/202104101721/#bing-cha-ji" class="toc-link">并查集</a>
                    
                    <ul>
                        
                        <li>
                            <a href="https://ffangl.github.io/202104101721/#lu-jing-ya-suo-chang-yong" class="toc-link">路径压缩（常用）</a>
                        </li>
                        
                        <li>
                            <a href="https://ffangl.github.io/202104101721/#qi-fa-shi-he-bing-an-zhi-pai-xu" class="toc-link">启发式合并（按秩排序）</a>
                        </li>
                        
                    </ul>
                    
                </li>
                
                <li>
                    <a href="https://ffangl.github.io/202104101721/#er-cha-shu" class="toc-link">二叉树</a>
                    
                    <ul>
                        
                        <li>
                            <a href="https://ffangl.github.io/202104101721/#qian-zhong-hou-xu-bian-li" class="toc-link">前中后序遍历</a>
                        </li>
                        
                        <li>
                            <a href="https://ffangl.github.io/202104101721/#ceng-xu-bian-li" class="toc-link">层序遍历</a>
                        </li>
                        
                        <li>
                            <a href="https://ffangl.github.io/202104101721/#qian-xu-zhong-xu-xu-lie-gou-zao-er-cha-shu" class="toc-link">前序中序序列构造二叉树</a>
                        </li>
                        
                        <li>
                            <a href="https://ffangl.github.io/202104101721/#zhong-xu-hou-xu-xu-lie-gou-zao-er-cha-shu" class="toc-link">中序后序序列构造二叉树</a>
                        </li>
                        
                        <li>
                            <a href="https://ffangl.github.io/202104101721/#er-cha-sou-suo-shu-yu-xu-lie-hua-he-fan-xu-lie-hua" class="toc-link">二叉搜索树与序列化和反序列化</a>
                        </li>
                        
                    </ul>
                    
                </li>
                
                <li>
                    <a href="https://ffangl.github.io/202104101721/#shu-zhuang-shu-zu-he-xian-duan-shu" class="toc-link">树状数组和线段树</a>
                    
                    <ul>
                        
                        <li>
                            <a href="https://ffangl.github.io/202104101721/#ying-yong-chang-jing" class="toc-link">应用场景</a>
                        </li>
                        
                        <li>
                            <a href="https://ffangl.github.io/202104101721/#" class="toc-link"></a>
                        </li>
                        
                        <li>
                            <a href="https://ffangl.github.io/202104101721/#jie-gou" class="toc-link">结构</a>
                        </li>
                        
                        <li>
                            <a href="https://ffangl.github.io/202104101721/#shu-zhuang-shu-zu-mo-ban" class="toc-link">树状数组模板</a>
                        </li>
                        
                        <li>
                            <a href="https://ffangl.github.io/202104101721/#xian-duan-shu-mo-ban" class="toc-link">线段树模板</a>
                        </li>
                        
                    </ul>
                    
                </li>
                
                <li>
                    <a href="https://ffangl.github.io/202104101721/#zi-dian-shu" class="toc-link">字典树</a>
                    
                    <ul>
                        
                        <li>
                            <a href="https://ffangl.github.io/202104101721/#trieshu-you-hua-dfs" class="toc-link">Trie树优化DFS</a>
                        </li>
                        
                        <li>
                            <a href="https://ffangl.github.io/202104101721/#mo-ban" class="toc-link">模板</a>
                        </li>
                        
                    </ul>
                    
                </li>
                
            </ul>
        </nav>
    </div>
</div>


<article class="post">
    
    <header class="post__header">
        <h1 class="post__title">
            <a href="https:&#x2F;&#x2F;ffangl.github.io&#x2F;202104101721&#x2F;">Data structure template</a>
        </h1>
        <div class="post__meta">
            <span class="post__time">2021-04-10</span>
            
        </div>
    </header>

    <div class="post-content">
      <span id="continue-reading"></span>
<h1 id="bing-cha-ji">并查集</h1>
<h2 id="lu-jing-ya-suo-chang-yong">路径压缩（常用）</h2>
<pre data-lang="c++" style="background-color:#2b303b;color:#c0c5ce;" class="language-c++ "><code class="language-c++" data-lang="c++"><span style="color:#b48ead;">class </span><span style="color:#ebcb8b;">UnionFind</span><span style="color:#eff1f5;">{
</span><span style="color:#b48ead;">public</span><span style="color:#eff1f5;">:
</span><span style="color:#eff1f5;">    </span><span style="color:#65737e;">//查找根节点，如果节点的父节点不为空，那就不断迭代。
</span><span style="color:#eff1f5;">    </span><span style="color:#b48ead;">int </span><span style="color:#8fa1b3;">find</span><span style="color:#eff1f5;">(</span><span style="color:#b48ead;">int </span><span style="color:#bf616a;">x</span><span style="color:#eff1f5;">){
</span><span style="color:#eff1f5;">        </span><span style="color:#b48ead;">int</span><span style="color:#eff1f5;"> root </span><span>=</span><span style="color:#eff1f5;"> x;
</span><span style="color:#eff1f5;">        
</span><span style="color:#eff1f5;">        </span><span style="color:#b48ead;">while</span><span style="color:#eff1f5;">(father[root] </span><span>!= -</span><span style="color:#d08770;">1</span><span style="color:#eff1f5;">){
</span><span style="color:#eff1f5;">            root </span><span>=</span><span style="color:#eff1f5;"> father[root];
</span><span style="color:#eff1f5;">        }
</span><span style="color:#eff1f5;">        </span><span style="color:#65737e;">//路径压缩
</span><span style="color:#eff1f5;">        </span><span style="color:#b48ead;">while</span><span style="color:#eff1f5;">(x </span><span>!=</span><span style="color:#eff1f5;"> root){
</span><span style="color:#eff1f5;">            </span><span style="color:#b48ead;">int</span><span style="color:#eff1f5;"> original_father </span><span>=</span><span style="color:#eff1f5;"> father[x];
</span><span style="color:#eff1f5;">            father[x] </span><span>=</span><span style="color:#eff1f5;"> root;
</span><span style="color:#eff1f5;">            x </span><span>=</span><span style="color:#eff1f5;"> original_father;
</span><span style="color:#eff1f5;">        }
</span><span style="color:#eff1f5;">        
</span><span style="color:#eff1f5;">        </span><span style="color:#b48ead;">return</span><span style="color:#eff1f5;"> root;
</span><span style="color:#eff1f5;">    }
</span><span style="color:#eff1f5;">    
</span><span style="color:#eff1f5;">    </span><span style="color:#65737e;">//判断两节点是否相连，判断它们的祖先是否相同
</span><span style="color:#eff1f5;">    </span><span style="color:#b48ead;">bool </span><span style="color:#8fa1b3;">is_connected</span><span style="color:#eff1f5;">(</span><span style="color:#b48ead;">int </span><span style="color:#bf616a;">x</span><span style="color:#eff1f5;">,</span><span style="color:#b48ead;">int </span><span style="color:#bf616a;">y</span><span style="color:#eff1f5;">){
</span><span style="color:#eff1f5;">        </span><span style="color:#b48ead;">return </span><span style="color:#bf616a;">find</span><span style="color:#eff1f5;">(x) </span><span>== </span><span style="color:#bf616a;">find</span><span style="color:#eff1f5;">(y);
</span><span style="color:#eff1f5;">    }
</span><span style="color:#eff1f5;">    
</span><span style="color:#eff1f5;">    </span><span style="color:#65737e;">//合并两个节点，y的根结点作为x根节点的父亲
</span><span style="color:#eff1f5;">    </span><span style="color:#b48ead;">void </span><span style="color:#8fa1b3;">merge</span><span style="color:#eff1f5;">(</span><span style="color:#b48ead;">int </span><span style="color:#bf616a;">x</span><span style="color:#eff1f5;">,</span><span style="color:#b48ead;">int </span><span style="color:#bf616a;">y</span><span style="color:#eff1f5;">){
</span><span style="color:#eff1f5;">        </span><span style="color:#b48ead;">int</span><span style="color:#eff1f5;"> root_x </span><span>= </span><span style="color:#bf616a;">find</span><span style="color:#eff1f5;">(x);
</span><span style="color:#eff1f5;">        </span><span style="color:#b48ead;">int</span><span style="color:#eff1f5;"> root_y </span><span>= </span><span style="color:#bf616a;">find</span><span style="color:#eff1f5;">(y);
</span><span style="color:#eff1f5;">        
</span><span style="color:#eff1f5;">        </span><span style="color:#b48ead;">if</span><span style="color:#eff1f5;">(root_x </span><span>!=</span><span style="color:#eff1f5;"> root_y){
</span><span style="color:#eff1f5;">            </span><span style="color:#65737e;">//root_x 接在 root_y 后面
</span><span style="color:#eff1f5;">            father[root_x] </span><span>=</span><span style="color:#eff1f5;"> root_y;
</span><span style="color:#eff1f5;">            num_of_sets</span><span>--</span><span style="color:#eff1f5;">;
</span><span style="color:#eff1f5;">        }
</span><span style="color:#eff1f5;">    }
</span><span style="color:#eff1f5;">    
</span><span style="color:#eff1f5;">    </span><span style="color:#65737e;">//添加新节点，它的父节点应该为空
</span><span style="color:#eff1f5;">    </span><span style="color:#b48ead;">void </span><span style="color:#8fa1b3;">add</span><span style="color:#eff1f5;">(</span><span style="color:#b48ead;">int </span><span style="color:#bf616a;">x</span><span style="color:#eff1f5;">){
</span><span style="color:#eff1f5;">        </span><span style="color:#b48ead;">if</span><span style="color:#eff1f5;">(</span><span>!</span><span style="color:#eff1f5;">father.</span><span style="color:#bf616a;">count</span><span style="color:#eff1f5;">(x)){
</span><span style="color:#eff1f5;">            father[x] </span><span>= -</span><span style="color:#d08770;">1</span><span style="color:#eff1f5;">;
</span><span style="color:#eff1f5;">            num_of_sets</span><span>++</span><span style="color:#eff1f5;">;
</span><span style="color:#eff1f5;">        }
</span><span style="color:#eff1f5;">    }
</span><span style="color:#eff1f5;">    </span><span style="color:#65737e;">//  返回集合数
</span><span style="color:#eff1f5;">    </span><span style="color:#b48ead;">int </span><span style="color:#8fa1b3;">get_num_of_sets</span><span style="color:#eff1f5;">(){
</span><span style="color:#eff1f5;">        </span><span style="color:#b48ead;">return</span><span style="color:#eff1f5;"> num_of_sets;
</span><span style="color:#eff1f5;">    }
</span><span style="color:#eff1f5;">    
</span><span style="color:#b48ead;">private</span><span style="color:#eff1f5;">:
</span><span style="color:#eff1f5;">    </span><span style="color:#65737e;">// 记录父节点
</span><span style="color:#eff1f5;">    unordered_map&lt;</span><span style="color:#b48ead;">int</span><span style="color:#eff1f5;">,</span><span style="color:#b48ead;">int</span><span style="color:#eff1f5;">&gt; father;
</span><span style="color:#eff1f5;">    </span><span style="color:#65737e;">// 记录集合数量
</span><span style="color:#eff1f5;">    </span><span style="color:#b48ead;">int</span><span style="color:#eff1f5;"> num_of_sets </span><span>= </span><span style="color:#d08770;">0</span><span style="color:#eff1f5;">;
</span><span style="color:#eff1f5;">}</span><span>;
</span><span>
</span></code></pre>
<h2 id="qi-fa-shi-he-bing-an-zhi-pai-xu">启发式合并（按秩排序）</h2>
<p>在平均情况下</p>
<ul>
<li>不使用启发式合并、只使用路径压缩，时间复杂度依然是 O(ma(m, n))</li>
<li>如果只使用启发式合并，而不使用路径压缩，时间复杂度为 O(mlogn)</li>
</ul>
<pre data-lang="c++" style="background-color:#2b303b;color:#c0c5ce;" class="language-c++ "><code class="language-c++" data-lang="c++"><span style="color:#b48ead;">class </span><span style="color:#ebcb8b;">UnionFind </span><span style="color:#eff1f5;">{
</span><span style="color:#b48ead;">public</span><span style="color:#eff1f5;">:
</span><span style="color:#eff1f5;">    vector&lt;</span><span style="color:#b48ead;">int</span><span style="color:#eff1f5;">&gt; parent;  </span><span style="color:#65737e;">// 下标idx为节点，parent[idx]为该节点的父亲
</span><span style="color:#eff1f5;">    vector&lt;</span><span style="color:#b48ead;">int</span><span style="color:#eff1f5;">&gt; size;    </span><span style="color:#65737e;">// 若idx为父亲根节点，size[idx]为该连通分量的大小
</span><span style="color:#eff1f5;">    </span><span style="color:#b48ead;">int</span><span style="color:#eff1f5;"> n;               </span><span style="color:#65737e;">// 节点数量
</span><span style="color:#eff1f5;">    </span><span style="color:#b48ead;">int</span><span style="color:#eff1f5;"> setCount;        </span><span style="color:#65737e;">// 连通分量的数量
</span><span style="color:#eff1f5;">
</span><span style="color:#b48ead;">public</span><span style="color:#eff1f5;">:
</span><span style="color:#eff1f5;">    </span><span style="color:#8fa1b3;">UnionFind</span><span style="color:#eff1f5;">(</span><span style="color:#b48ead;">int </span><span style="color:#bf616a;">_n</span><span style="color:#eff1f5;">) : </span><span style="color:#bf616a;">n</span><span style="color:#eff1f5;">(_n), </span><span style="color:#bf616a;">setCount</span><span style="color:#eff1f5;">(_n), </span><span style="color:#bf616a;">parent</span><span style="color:#eff1f5;">(_n), </span><span style="color:#bf616a;">size</span><span style="color:#eff1f5;">(_n, </span><span style="color:#d08770;">1</span><span style="color:#eff1f5;">) {
</span><span style="color:#eff1f5;">        </span><span style="color:#bf616a;">iota</span><span style="color:#eff1f5;">(parent.</span><span style="color:#bf616a;">begin</span><span style="color:#eff1f5;">(), parent.</span><span style="color:#bf616a;">end</span><span style="color:#eff1f5;">(), </span><span style="color:#d08770;">0</span><span style="color:#eff1f5;">);
</span><span style="color:#eff1f5;">    }
</span><span style="color:#eff1f5;">
</span><span style="color:#eff1f5;">    </span><span style="color:#65737e;">//递归查找根节点，如果节点i的父节点为本身就找到了根，结束递归
</span><span style="color:#eff1f5;">    </span><span style="color:#b48ead;">int </span><span style="color:#8fa1b3;">find</span><span style="color:#eff1f5;">(</span><span style="color:#b48ead;">int </span><span style="color:#bf616a;">x</span><span style="color:#eff1f5;">) {
</span><span style="color:#eff1f5;">        </span><span style="color:#b48ead;">return</span><span style="color:#eff1f5;"> parent[x] </span><span>==</span><span style="color:#eff1f5;"> x </span><span>?</span><span style="color:#eff1f5;"> x </span><span>:</span><span style="color:#eff1f5;"> parent[x] </span><span>= </span><span style="color:#bf616a;">find</span><span style="color:#eff1f5;">(parent[x]);
</span><span style="color:#eff1f5;">    }
</span><span style="color:#eff1f5;">
</span><span style="color:#eff1f5;">    </span><span style="color:#65737e;">//合并两个节点
</span><span style="color:#eff1f5;">    </span><span style="color:#b48ead;">bool </span><span style="color:#8fa1b3;">unite</span><span style="color:#eff1f5;">(</span><span style="color:#b48ead;">int </span><span style="color:#bf616a;">x</span><span style="color:#eff1f5;">, </span><span style="color:#b48ead;">int </span><span style="color:#bf616a;">y</span><span style="color:#eff1f5;">) {
</span><span style="color:#eff1f5;">        x </span><span>= </span><span style="color:#bf616a;">find</span><span style="color:#eff1f5;">(x);
</span><span style="color:#eff1f5;">        y </span><span>= </span><span style="color:#bf616a;">find</span><span style="color:#eff1f5;">(y);
</span><span style="color:#eff1f5;">        </span><span style="color:#b48ead;">if </span><span style="color:#eff1f5;">(x </span><span>==</span><span style="color:#eff1f5;"> y) </span><span style="color:#b48ead;">return </span><span style="color:#d08770;">false</span><span style="color:#eff1f5;">;
</span><span style="color:#eff1f5;">
</span><span style="color:#eff1f5;">        </span><span style="color:#b48ead;">if </span><span style="color:#eff1f5;">(size[x] </span><span>&lt;</span><span style="color:#eff1f5;"> size[y]) {
</span><span style="color:#eff1f5;">            </span><span style="color:#bf616a;">swap</span><span style="color:#eff1f5;">(x, y);
</span><span style="color:#eff1f5;">        }
</span><span style="color:#eff1f5;">        parent[y] </span><span>=</span><span style="color:#eff1f5;"> x;       </span><span style="color:#65737e;">// x 作为 y 的父亲
</span><span style="color:#eff1f5;">        size[x] </span><span>+=</span><span style="color:#eff1f5;"> size[y];  </span><span style="color:#65737e;">// 父亲节点x的联通分量大小加上y节点的
</span><span style="color:#eff1f5;">        </span><span>--</span><span style="color:#eff1f5;">setCount;
</span><span style="color:#eff1f5;">        </span><span style="color:#b48ead;">return </span><span style="color:#d08770;">true</span><span style="color:#eff1f5;">;
</span><span style="color:#eff1f5;">    }
</span><span style="color:#eff1f5;">
</span><span style="color:#eff1f5;">    </span><span style="color:#65737e;">//判断两个节点是否连通
</span><span style="color:#eff1f5;">    </span><span style="color:#b48ead;">bool </span><span style="color:#8fa1b3;">is_connected</span><span style="color:#eff1f5;">(</span><span style="color:#b48ead;">int </span><span style="color:#bf616a;">x</span><span style="color:#eff1f5;">, </span><span style="color:#b48ead;">int </span><span style="color:#bf616a;">y</span><span style="color:#eff1f5;">) {
</span><span style="color:#eff1f5;">        x </span><span>= </span><span style="color:#bf616a;">find</span><span style="color:#eff1f5;">(x);
</span><span style="color:#eff1f5;">        y </span><span>= </span><span style="color:#bf616a;">find</span><span style="color:#eff1f5;">(y);
</span><span style="color:#eff1f5;">        </span><span style="color:#b48ead;">return</span><span style="color:#eff1f5;"> x </span><span>==</span><span style="color:#eff1f5;"> y;
</span><span style="color:#eff1f5;">    }
</span><span style="color:#eff1f5;">
</span><span style="color:#eff1f5;">    </span><span style="color:#65737e;">//断开节点与他父节点的连接
</span><span style="color:#eff1f5;">    </span><span style="color:#b48ead;">void </span><span style="color:#8fa1b3;">disconnected</span><span style="color:#eff1f5;">(</span><span style="color:#b48ead;">int </span><span style="color:#bf616a;">x</span><span style="color:#eff1f5;">) {
</span><span style="color:#eff1f5;">        </span><span style="color:#b48ead;">if </span><span style="color:#eff1f5;">(x </span><span>!=</span><span style="color:#eff1f5;"> parent[x]) {
</span><span style="color:#eff1f5;">            parent[x] </span><span>=</span><span style="color:#eff1f5;"> x;
</span><span style="color:#eff1f5;">            size[x] </span><span>= </span><span style="color:#d08770;">1</span><span style="color:#eff1f5;">;
</span><span style="color:#eff1f5;">            </span><span>++</span><span style="color:#eff1f5;">setCount;
</span><span style="color:#eff1f5;">        }
</span><span style="color:#eff1f5;">    }
</span><span style="color:#eff1f5;">}</span><span>;
</span></code></pre>
<h1 id="er-cha-shu">二叉树</h1>
<pre data-lang="c++" style="background-color:#2b303b;color:#c0c5ce;" class="language-c++ "><code class="language-c++" data-lang="c++"><span style="color:#65737e;">// Definition for a binary tree node.
</span><span style="color:#b48ead;">struct </span><span>TreeNode {
</span><span>      </span><span style="color:#b48ead;">int</span><span> val;
</span><span>      TreeNode *left;
</span><span>      TreeNode *right;
</span><span>      </span><span style="color:#8fa1b3;">TreeNode</span><span>() : </span><span style="color:#bf616a;">val</span><span>(</span><span style="color:#d08770;">0</span><span>), </span><span style="color:#bf616a;">left</span><span>(</span><span style="color:#d08770;">nullptr</span><span>), </span><span style="color:#bf616a;">right</span><span>(</span><span style="color:#d08770;">nullptr</span><span>) {}
</span><span>      </span><span style="color:#8fa1b3;">TreeNode</span><span>(</span><span style="color:#b48ead;">int </span><span style="color:#bf616a;">x</span><span>) : </span><span style="color:#bf616a;">val</span><span>(x), </span><span style="color:#bf616a;">left</span><span>(</span><span style="color:#d08770;">nullptr</span><span>), </span><span style="color:#bf616a;">right</span><span>(</span><span style="color:#d08770;">nullptr</span><span>) {}
</span><span>      </span><span style="color:#8fa1b3;">TreeNode</span><span>(</span><span style="color:#b48ead;">int </span><span style="color:#bf616a;">x</span><span>, TreeNode *</span><span style="color:#bf616a;">left</span><span>, TreeNode *</span><span style="color:#bf616a;">right</span><span>) : </span><span style="color:#bf616a;">val</span><span>(x), </span><span style="color:#bf616a;">left</span><span>(left), </span><span style="color:#bf616a;">right</span><span>(right) {}
</span><span>};
</span></code></pre>
<h2 id="qian-zhong-hou-xu-bian-li">前中后序遍历</h2>
<pre data-lang="c++" style="background-color:#2b303b;color:#c0c5ce;" class="language-c++ "><code class="language-c++" data-lang="c++"><span style="color:#b48ead;">class </span><span style="color:#ebcb8b;">Solution </span><span style="color:#eff1f5;">{
</span><span style="color:#b48ead;">public</span><span style="color:#eff1f5;">:
</span><span style="color:#eff1f5;">    </span><span style="color:#65737e;">//前序
</span><span style="color:#eff1f5;">    </span><span style="color:#b48ead;">void </span><span style="color:#8fa1b3;">dfs</span><span style="color:#eff1f5;">(TreeNode </span><span>*</span><span style="color:#bf616a;">cur</span><span style="color:#eff1f5;">, vector&lt;</span><span style="color:#b48ead;">int</span><span style="color:#eff1f5;">&gt; </span><span>&amp;</span><span style="color:#bf616a;">vec</span><span style="color:#eff1f5;">) {
</span><span style="color:#eff1f5;">        </span><span style="color:#b48ead;">if </span><span style="color:#eff1f5;">(cur </span><span>== </span><span style="color:#d08770;">NULL</span><span style="color:#eff1f5;">) </span><span style="color:#b48ead;">return</span><span style="color:#eff1f5;">;
</span><span style="color:#eff1f5;">        vec.</span><span style="color:#bf616a;">push_back</span><span style="color:#eff1f5;">(cur-&gt;</span><span style="color:#bf616a;">val</span><span style="color:#eff1f5;">);  </span><span style="color:#65737e;">// 中
</span><span style="color:#eff1f5;">        </span><span style="color:#bf616a;">dfs</span><span style="color:#eff1f5;">(cur-&gt;</span><span style="color:#bf616a;">left</span><span style="color:#eff1f5;">, vec);      </span><span style="color:#65737e;">// 左
</span><span style="color:#eff1f5;">        </span><span style="color:#bf616a;">dfs</span><span style="color:#eff1f5;">(cur-&gt;</span><span style="color:#bf616a;">right</span><span style="color:#eff1f5;">, vec);     </span><span style="color:#65737e;">// 右
</span><span style="color:#eff1f5;">    }
</span><span style="color:#eff1f5;">    </span><span style="color:#65737e;">//中序
</span><span style="color:#eff1f5;">    </span><span style="color:#b48ead;">void </span><span style="color:#8fa1b3;">dfs</span><span style="color:#eff1f5;">(TreeNode </span><span>*</span><span style="color:#bf616a;">cur</span><span style="color:#eff1f5;">, vector&lt;</span><span style="color:#b48ead;">int</span><span style="color:#eff1f5;">&gt; </span><span>&amp;</span><span style="color:#bf616a;">vec</span><span style="color:#eff1f5;">) {
</span><span style="color:#eff1f5;">        </span><span style="color:#b48ead;">if </span><span style="color:#eff1f5;">(cur </span><span>== </span><span style="color:#d08770;">NULL</span><span style="color:#eff1f5;">) </span><span style="color:#b48ead;">return</span><span style="color:#eff1f5;">;
</span><span style="color:#eff1f5;">        </span><span style="color:#bf616a;">dfs</span><span style="color:#eff1f5;">(cur-&gt;</span><span style="color:#bf616a;">left</span><span style="color:#eff1f5;">, vec);
</span><span style="color:#eff1f5;">        vec.</span><span style="color:#bf616a;">push_back</span><span style="color:#eff1f5;">(cur-&gt;</span><span style="color:#bf616a;">val</span><span style="color:#eff1f5;">);
</span><span style="color:#eff1f5;">        </span><span style="color:#bf616a;">dfs</span><span style="color:#eff1f5;">(cur-&gt;</span><span style="color:#bf616a;">right</span><span style="color:#eff1f5;">, vec);
</span><span style="color:#eff1f5;">    }
</span><span style="color:#eff1f5;">    </span><span style="color:#65737e;">//后序
</span><span style="color:#eff1f5;">     </span><span style="color:#b48ead;">void </span><span style="color:#8fa1b3;">dfs</span><span style="color:#eff1f5;">(TreeNode </span><span>*</span><span style="color:#bf616a;">cur</span><span style="color:#eff1f5;">, vector&lt;</span><span style="color:#b48ead;">int</span><span style="color:#eff1f5;">&gt; </span><span>&amp;</span><span style="color:#bf616a;">vec</span><span style="color:#eff1f5;">) {
</span><span style="color:#eff1f5;">        </span><span style="color:#b48ead;">if </span><span style="color:#eff1f5;">(cur </span><span>== </span><span style="color:#d08770;">NULL</span><span style="color:#eff1f5;">) </span><span style="color:#b48ead;">return</span><span style="color:#eff1f5;">;
</span><span style="color:#eff1f5;">        </span><span style="color:#bf616a;">dfs</span><span style="color:#eff1f5;">(cur-&gt;</span><span style="color:#bf616a;">left</span><span style="color:#eff1f5;">, vec);
</span><span style="color:#eff1f5;">        </span><span style="color:#bf616a;">dfs</span><span style="color:#eff1f5;">(cur-&gt;</span><span style="color:#bf616a;">right</span><span style="color:#eff1f5;">, vec);
</span><span style="color:#eff1f5;">        vec.</span><span style="color:#bf616a;">push_back</span><span style="color:#eff1f5;">(cur-&gt;</span><span style="color:#bf616a;">val</span><span style="color:#eff1f5;">);
</span><span style="color:#eff1f5;">    }
</span><span style="color:#eff1f5;">    vector&lt;</span><span style="color:#b48ead;">int</span><span style="color:#eff1f5;">&gt; </span><span style="color:#8fa1b3;">Traversal</span><span style="color:#eff1f5;">(TreeNode </span><span>*</span><span style="color:#bf616a;">root</span><span style="color:#eff1f5;">) {
</span><span style="color:#eff1f5;">        vector&lt;</span><span style="color:#b48ead;">int</span><span style="color:#eff1f5;">&gt; res;
</span><span style="color:#eff1f5;">        </span><span style="color:#bf616a;">dfs</span><span style="color:#eff1f5;">(root, res);
</span><span style="color:#eff1f5;">        </span><span style="color:#b48ead;">return</span><span style="color:#eff1f5;"> res;
</span><span style="color:#eff1f5;">    }
</span><span style="color:#eff1f5;">}</span><span>;
</span></code></pre>
<h2 id="ceng-xu-bian-li">层序遍历</h2>
<pre data-lang="c++" style="background-color:#2b303b;color:#c0c5ce;" class="language-c++ "><code class="language-c++" data-lang="c++"><span style="color:#b48ead;">class </span><span style="color:#ebcb8b;">Solution </span><span style="color:#eff1f5;">{
</span><span style="color:#b48ead;">public</span><span style="color:#eff1f5;">:
</span><span style="color:#eff1f5;">    vector&lt;vector&lt;</span><span style="color:#b48ead;">int</span><span style="color:#eff1f5;">&gt;&gt; </span><span style="color:#8fa1b3;">levelOrder</span><span style="color:#eff1f5;">(TreeNode </span><span>*</span><span style="color:#bf616a;">root</span><span style="color:#eff1f5;">) {
</span><span style="color:#eff1f5;">        vector&lt;vector&lt;</span><span style="color:#b48ead;">int</span><span style="color:#eff1f5;">&gt;&gt; res;
</span><span style="color:#eff1f5;">        </span><span style="color:#b48ead;">if </span><span style="color:#eff1f5;">(</span><span>!</span><span style="color:#eff1f5;">root) </span><span style="color:#b48ead;">return</span><span style="color:#eff1f5;"> res;
</span><span style="color:#eff1f5;">
</span><span style="color:#eff1f5;">        queue</span><span>&lt;</span><span style="color:#eff1f5;">TreeNode </span><span>*&gt;</span><span style="color:#eff1f5;"> q;
</span><span style="color:#eff1f5;">        q.</span><span style="color:#bf616a;">push</span><span style="color:#eff1f5;">(root);
</span><span style="color:#eff1f5;">        </span><span style="color:#b48ead;">while </span><span style="color:#eff1f5;">(</span><span>!</span><span style="color:#eff1f5;">q.</span><span style="color:#bf616a;">empty</span><span style="color:#eff1f5;">()) {
</span><span style="color:#eff1f5;">            </span><span style="color:#b48ead;">int</span><span style="color:#eff1f5;"> layerSz </span><span>=</span><span style="color:#eff1f5;"> q.</span><span style="color:#bf616a;">size</span><span style="color:#eff1f5;">();
</span><span style="color:#eff1f5;">            vector&lt;</span><span style="color:#b48ead;">int</span><span style="color:#eff1f5;">&gt; layer;
</span><span style="color:#eff1f5;">            </span><span style="color:#b48ead;">for </span><span style="color:#eff1f5;">(</span><span style="color:#b48ead;">int</span><span style="color:#eff1f5;"> i </span><span>= </span><span style="color:#d08770;">0</span><span style="color:#eff1f5;">; i </span><span>&lt;</span><span style="color:#eff1f5;"> layerSz; i</span><span>++</span><span style="color:#eff1f5;">) {
</span><span style="color:#eff1f5;">                </span><span style="color:#b48ead;">auto</span><span style="color:#eff1f5;"> node </span><span>=</span><span style="color:#eff1f5;"> q.</span><span style="color:#bf616a;">front</span><span style="color:#eff1f5;">();
</span><span style="color:#eff1f5;">                q.</span><span style="color:#bf616a;">pop</span><span style="color:#eff1f5;">();
</span><span style="color:#eff1f5;">                layer.</span><span style="color:#bf616a;">push_back</span><span style="color:#eff1f5;">(node-&gt;</span><span style="color:#bf616a;">val</span><span style="color:#eff1f5;">);
</span><span style="color:#eff1f5;">                </span><span style="color:#b48ead;">if </span><span style="color:#eff1f5;">(node-&gt;</span><span style="color:#bf616a;">left</span><span style="color:#eff1f5;">) q.</span><span style="color:#bf616a;">push</span><span style="color:#eff1f5;">(node-&gt;</span><span style="color:#bf616a;">left</span><span style="color:#eff1f5;">);
</span><span style="color:#eff1f5;">                </span><span style="color:#b48ead;">if </span><span style="color:#eff1f5;">(node-&gt;</span><span style="color:#bf616a;">right</span><span style="color:#eff1f5;">) q.</span><span style="color:#bf616a;">push</span><span style="color:#eff1f5;">(node-&gt;</span><span style="color:#bf616a;">right</span><span style="color:#eff1f5;">);
</span><span style="color:#eff1f5;">            }
</span><span style="color:#eff1f5;">            res.</span><span style="color:#bf616a;">push_back</span><span style="color:#eff1f5;">(layer);
</span><span style="color:#eff1f5;">        }
</span><span style="color:#eff1f5;">        </span><span style="color:#b48ead;">return</span><span style="color:#eff1f5;"> res;
</span><span style="color:#eff1f5;">    }
</span><span style="color:#eff1f5;">}</span><span>;
</span></code></pre>
<h2 id="qian-xu-zhong-xu-xu-lie-gou-zao-er-cha-shu">前序中序序列构造二叉树</h2>
<pre data-lang="c++" style="background-color:#2b303b;color:#c0c5ce;" class="language-c++ "><code class="language-c++" data-lang="c++"><span style="color:#b48ead;">class </span><span style="color:#ebcb8b;">Solution </span><span style="color:#eff1f5;">{
</span><span style="color:#b48ead;">private</span><span style="color:#eff1f5;">:
</span><span style="color:#eff1f5;">    unordered_map&lt;</span><span style="color:#b48ead;">int</span><span style="color:#eff1f5;">, </span><span style="color:#b48ead;">int</span><span style="color:#eff1f5;">&gt; index;
</span><span style="color:#eff1f5;">
</span><span style="color:#b48ead;">public</span><span style="color:#eff1f5;">:
</span><span style="color:#eff1f5;">    TreeNode</span><span>* </span><span style="color:#8fa1b3;">myBuildTree</span><span style="color:#eff1f5;">(</span><span style="color:#b48ead;">const</span><span style="color:#eff1f5;"> vector&lt;</span><span style="color:#b48ead;">int</span><span style="color:#eff1f5;">&gt;</span><span>&amp; </span><span style="color:#bf616a;">preorder</span><span style="color:#eff1f5;">, </span><span style="color:#b48ead;">const</span><span style="color:#eff1f5;"> vector&lt;</span><span style="color:#b48ead;">int</span><span style="color:#eff1f5;">&gt;</span><span>&amp; </span><span style="color:#bf616a;">inorder</span><span style="color:#eff1f5;">, </span><span style="color:#b48ead;">int </span><span style="color:#bf616a;">preorder_left</span><span style="color:#eff1f5;">, </span><span style="color:#b48ead;">int </span><span style="color:#bf616a;">preorder_right</span><span style="color:#eff1f5;">, </span><span style="color:#b48ead;">int </span><span style="color:#bf616a;">inorder_left</span><span style="color:#eff1f5;">, </span><span style="color:#b48ead;">int </span><span style="color:#bf616a;">inorder_right</span><span style="color:#eff1f5;">) {
</span><span style="color:#eff1f5;">        </span><span style="color:#b48ead;">if </span><span style="color:#eff1f5;">(preorder_left </span><span>&gt;</span><span style="color:#eff1f5;"> preorder_right) {
</span><span style="color:#eff1f5;">            </span><span style="color:#b48ead;">return </span><span style="color:#d08770;">nullptr</span><span style="color:#eff1f5;">;
</span><span style="color:#eff1f5;">        }
</span><span style="color:#eff1f5;">        
</span><span style="color:#eff1f5;">        </span><span style="color:#65737e;">// 前序遍历中的第一个节点就是根节点
</span><span style="color:#eff1f5;">        </span><span style="color:#b48ead;">int</span><span style="color:#eff1f5;"> preorder_root </span><span>=</span><span style="color:#eff1f5;"> preorder_left;
</span><span style="color:#eff1f5;">        </span><span style="color:#65737e;">// 在中序遍历中定位根节点
</span><span style="color:#eff1f5;">        </span><span style="color:#b48ead;">int</span><span style="color:#eff1f5;"> inorder_root </span><span>=</span><span style="color:#eff1f5;"> index[preorder[preorder_root]];
</span><span style="color:#eff1f5;">        
</span><span style="color:#eff1f5;">        </span><span style="color:#65737e;">// 先把根节点建立出来
</span><span style="color:#eff1f5;">        TreeNode</span><span>*</span><span style="color:#eff1f5;"> root </span><span>= </span><span style="color:#b48ead;">new </span><span style="color:#bf616a;">TreeNode</span><span style="color:#eff1f5;">(preorder[preorder_root]);
</span><span style="color:#eff1f5;">        </span><span style="color:#65737e;">// 得到左子树中的节点数目
</span><span style="color:#eff1f5;">        </span><span style="color:#b48ead;">int</span><span style="color:#eff1f5;"> size_left_subtree </span><span>=</span><span style="color:#eff1f5;"> inorder_root </span><span>-</span><span style="color:#eff1f5;"> inorder_left;
</span><span style="color:#eff1f5;">        </span><span style="color:#65737e;">// 递归地构造左子树，并连接到根节点
</span><span style="color:#eff1f5;">        </span><span style="color:#65737e;">// 先序遍历中「从 左边界+1 开始的 size_left_subtree」个元素就对应了中序遍历中「从 左边界 开始到 根节点定位-1」的元素
</span><span style="color:#eff1f5;">        root-&gt;</span><span style="color:#bf616a;">left </span><span>= </span><span style="color:#bf616a;">myBuildTree</span><span style="color:#eff1f5;">(preorder, inorder, preorder_left </span><span>+ </span><span style="color:#d08770;">1</span><span style="color:#eff1f5;">, preorder_left </span><span>+</span><span style="color:#eff1f5;"> size_left_subtree, inorder_left, inorder_root </span><span>- </span><span style="color:#d08770;">1</span><span style="color:#eff1f5;">);
</span><span style="color:#eff1f5;">        </span><span style="color:#65737e;">// 递归地构造右子树，并连接到根节点
</span><span style="color:#eff1f5;">        </span><span style="color:#65737e;">// 先序遍历中「从 左边界+1+左子树节点数目 开始到 右边界」的元素就对应了中序遍历中「从 根节点定位+1 到 右边界」的元素
</span><span style="color:#eff1f5;">        root-&gt;</span><span style="color:#bf616a;">right </span><span>= </span><span style="color:#bf616a;">myBuildTree</span><span style="color:#eff1f5;">(preorder, inorder, preorder_left </span><span>+</span><span style="color:#eff1f5;"> size_left_subtree </span><span>+ </span><span style="color:#d08770;">1</span><span style="color:#eff1f5;">, preorder_right, inorder_root </span><span>+ </span><span style="color:#d08770;">1</span><span style="color:#eff1f5;">, inorder_right);
</span><span style="color:#eff1f5;">        </span><span style="color:#b48ead;">return</span><span style="color:#eff1f5;"> root;
</span><span style="color:#eff1f5;">    }
</span><span style="color:#eff1f5;">
</span><span style="color:#eff1f5;">    TreeNode</span><span>* </span><span style="color:#8fa1b3;">buildTree</span><span style="color:#eff1f5;">(vector&lt;</span><span style="color:#b48ead;">int</span><span style="color:#eff1f5;">&gt;</span><span>&amp; </span><span style="color:#bf616a;">preorder</span><span style="color:#eff1f5;">, vector&lt;</span><span style="color:#b48ead;">int</span><span style="color:#eff1f5;">&gt;</span><span>&amp; </span><span style="color:#bf616a;">inorder</span><span style="color:#eff1f5;">) {
</span><span style="color:#eff1f5;">        </span><span style="color:#b48ead;">int</span><span style="color:#eff1f5;"> n </span><span>=</span><span style="color:#eff1f5;"> preorder.</span><span style="color:#bf616a;">size</span><span style="color:#eff1f5;">();
</span><span style="color:#eff1f5;">        </span><span style="color:#65737e;">// 构造哈希映射，帮助我们快速定位根节点
</span><span style="color:#eff1f5;">        </span><span style="color:#b48ead;">for </span><span style="color:#eff1f5;">(</span><span style="color:#b48ead;">int</span><span style="color:#eff1f5;"> i </span><span>= </span><span style="color:#d08770;">0</span><span style="color:#eff1f5;">; i </span><span>&lt;</span><span style="color:#eff1f5;"> n; </span><span>++</span><span style="color:#eff1f5;">i) {
</span><span style="color:#eff1f5;">            index[inorder[i]] </span><span>=</span><span style="color:#eff1f5;"> i;
</span><span style="color:#eff1f5;">        }
</span><span style="color:#eff1f5;">        </span><span style="color:#b48ead;">return </span><span style="color:#bf616a;">myBuildTree</span><span style="color:#eff1f5;">(preorder, inorder, </span><span style="color:#d08770;">0</span><span style="color:#eff1f5;">, n </span><span>- </span><span style="color:#d08770;">1</span><span style="color:#eff1f5;">, </span><span style="color:#d08770;">0</span><span style="color:#eff1f5;">, n </span><span>- </span><span style="color:#d08770;">1</span><span style="color:#eff1f5;">);
</span><span style="color:#eff1f5;">    }
</span><span style="color:#eff1f5;">}</span><span>;
</span></code></pre>
<p><strong>复杂度分析</strong></p>
<p>时间复杂度：O(n)，其中 n 是树中的节点个数。</p>
<p>空间复杂度：O(n))，除去返回的答案需要的 O(n)空间之外，我们还需要使用 O(n) 的空间存储哈希映射，以及 O(h)其中 h 是树的高度）的空间表示递归时栈空间。这里 h &lt; n，所以总空间复杂度为 O(n)。</p>
<h2 id="zhong-xu-hou-xu-xu-lie-gou-zao-er-cha-shu">中序后序序列构造二叉树</h2>
<pre data-lang="c++" style="background-color:#2b303b;color:#c0c5ce;" class="language-c++ "><code class="language-c++" data-lang="c++"><span style="color:#b48ead;">class </span><span style="color:#ebcb8b;">Solution </span><span style="color:#eff1f5;">{
</span><span style="color:#eff1f5;">    </span><span style="color:#b48ead;">int</span><span style="color:#eff1f5;"> post_idx;
</span><span style="color:#eff1f5;">    unordered_map&lt;</span><span style="color:#b48ead;">int</span><span style="color:#eff1f5;">, </span><span style="color:#b48ead;">int</span><span style="color:#eff1f5;">&gt; idx_map;
</span><span style="color:#b48ead;">public</span><span style="color:#eff1f5;">:
</span><span style="color:#eff1f5;">    TreeNode</span><span>* </span><span style="color:#8fa1b3;">helper</span><span style="color:#eff1f5;">(</span><span style="color:#b48ead;">int </span><span style="color:#bf616a;">in_left</span><span style="color:#eff1f5;">, </span><span style="color:#b48ead;">int </span><span style="color:#bf616a;">in_right</span><span style="color:#eff1f5;">, vector&lt;</span><span style="color:#b48ead;">int</span><span style="color:#eff1f5;">&gt;</span><span>&amp; </span><span style="color:#bf616a;">inorder</span><span style="color:#eff1f5;">, vector&lt;</span><span style="color:#b48ead;">int</span><span style="color:#eff1f5;">&gt;</span><span>&amp; </span><span style="color:#bf616a;">postorder</span><span style="color:#eff1f5;">){
</span><span style="color:#eff1f5;">        </span><span style="color:#65737e;">// 如果这里没有节点构造二叉树了，就结束
</span><span style="color:#eff1f5;">        </span><span style="color:#b48ead;">if </span><span style="color:#eff1f5;">(in_left </span><span>&gt;</span><span style="color:#eff1f5;"> in_right) {
</span><span style="color:#eff1f5;">            </span><span style="color:#b48ead;">return </span><span style="color:#d08770;">nullptr</span><span style="color:#eff1f5;">;
</span><span style="color:#eff1f5;">        }
</span><span style="color:#eff1f5;">
</span><span style="color:#eff1f5;">        </span><span style="color:#65737e;">// 选择 post_idx 位置的元素作为当前子树根节点
</span><span style="color:#eff1f5;">        </span><span style="color:#b48ead;">int</span><span style="color:#eff1f5;"> root_val </span><span>=</span><span style="color:#eff1f5;"> postorder[post_idx];
</span><span style="color:#eff1f5;">        TreeNode</span><span>*</span><span style="color:#eff1f5;"> root </span><span>= </span><span style="color:#b48ead;">new </span><span style="color:#bf616a;">TreeNode</span><span style="color:#eff1f5;">(root_val);
</span><span style="color:#eff1f5;">
</span><span style="color:#eff1f5;">        </span><span style="color:#65737e;">// 根据 root 所在位置分成左右两棵子树
</span><span style="color:#eff1f5;">        </span><span style="color:#b48ead;">int</span><span style="color:#eff1f5;"> index </span><span>=</span><span style="color:#eff1f5;"> idx_map[root_val];
</span><span style="color:#eff1f5;">
</span><span style="color:#eff1f5;">        </span><span style="color:#65737e;">// 下标减一
</span><span style="color:#eff1f5;">        post_idx</span><span>--</span><span style="color:#eff1f5;">;
</span><span style="color:#eff1f5;">        </span><span style="color:#65737e;">// 构造右子树
</span><span style="color:#eff1f5;">        root-&gt;</span><span style="color:#bf616a;">right </span><span>= </span><span style="color:#bf616a;">helper</span><span style="color:#eff1f5;">(index </span><span>+ </span><span style="color:#d08770;">1</span><span style="color:#eff1f5;">, in_right, inorder, postorder);
</span><span style="color:#eff1f5;">        </span><span style="color:#65737e;">// 构造左子树
</span><span style="color:#eff1f5;">        root-&gt;</span><span style="color:#bf616a;">left </span><span>= </span><span style="color:#bf616a;">helper</span><span style="color:#eff1f5;">(in_left, index </span><span>- </span><span style="color:#d08770;">1</span><span style="color:#eff1f5;">, inorder, postorder);
</span><span style="color:#eff1f5;">        </span><span style="color:#b48ead;">return</span><span style="color:#eff1f5;"> root;
</span><span style="color:#eff1f5;">    }
</span><span style="color:#eff1f5;">    TreeNode</span><span>* </span><span style="color:#8fa1b3;">buildTree</span><span style="color:#eff1f5;">(vector&lt;</span><span style="color:#b48ead;">int</span><span style="color:#eff1f5;">&gt;</span><span>&amp; </span><span style="color:#bf616a;">inorder</span><span style="color:#eff1f5;">, vector&lt;</span><span style="color:#b48ead;">int</span><span style="color:#eff1f5;">&gt;</span><span>&amp; </span><span style="color:#bf616a;">postorder</span><span style="color:#eff1f5;">) {
</span><span style="color:#eff1f5;">        </span><span style="color:#65737e;">// 从后序遍历的最后一个元素开始
</span><span style="color:#eff1f5;">        post_idx </span><span>= </span><span style="color:#eff1f5;">(</span><span style="color:#b48ead;">int</span><span style="color:#eff1f5;">)postorder.</span><span style="color:#bf616a;">size</span><span style="color:#eff1f5;">() </span><span>- </span><span style="color:#d08770;">1</span><span style="color:#eff1f5;">;
</span><span style="color:#eff1f5;">
</span><span style="color:#eff1f5;">        </span><span style="color:#65737e;">// 建立（元素，下标）键值对的哈希表
</span><span style="color:#eff1f5;">        </span><span style="color:#b48ead;">int</span><span style="color:#eff1f5;"> idx </span><span>= </span><span style="color:#d08770;">0</span><span style="color:#eff1f5;">;
</span><span style="color:#eff1f5;">        </span><span style="color:#b48ead;">for </span><span style="color:#eff1f5;">(</span><span style="color:#b48ead;">auto</span><span>&amp;</span><span style="color:#eff1f5;"> val </span><span>:</span><span style="color:#eff1f5;"> inorder) {
</span><span style="color:#eff1f5;">            idx_map[val] </span><span>=</span><span style="color:#eff1f5;"> idx</span><span>++</span><span style="color:#eff1f5;">;
</span><span style="color:#eff1f5;">        }
</span><span style="color:#eff1f5;">        </span><span style="color:#b48ead;">return </span><span style="color:#bf616a;">helper</span><span style="color:#eff1f5;">(</span><span style="color:#d08770;">0</span><span style="color:#eff1f5;">, (</span><span style="color:#b48ead;">int</span><span style="color:#eff1f5;">)inorder.</span><span style="color:#bf616a;">size</span><span style="color:#eff1f5;">() </span><span>- </span><span style="color:#d08770;">1</span><span style="color:#eff1f5;">, inorder, postorder);
</span><span style="color:#eff1f5;">    }
</span><span style="color:#eff1f5;">}</span><span>;
</span></code></pre>
<p><strong>复杂度分析</strong></p>
<p>时间复杂度：O(n)，其中 n 是树中的节点个数。</p>
<p>空间复杂度：O(n)。我们需要使用 O(n)的空间存储哈希表，以及 O(h)（其中 h 是树的高度）的空间表示递归时栈空间。这里 h &lt; n，所以总空间复杂度为 O(n)。</p>
<h2 id="er-cha-sou-suo-shu-yu-xu-lie-hua-he-fan-xu-lie-hua">二叉搜索树与序列化和反序列化</h2>
<p>二叉搜索树能只够通过前序序列或后序序列构造</p>
<h3 id="xu-lie-hua-he-fan-xu-lie-hua-er-cha-sou-suo-shu">序列化和反序列化二叉搜索树</h3>
<p>普通二叉树同样适用</p>
<h4 id="bfs">BFS</h4>
<pre data-lang="c++" style="background-color:#2b303b;color:#c0c5ce;" class="language-c++ "><code class="language-c++" data-lang="c++"><span>public </span><span style="color:#b48ead;">class</span><span> Codec {
</span><span>
</span><span>    </span><span style="color:#65737e;">//把树转化为字符串（使用BFS遍历）
</span><span>    public String </span><span style="color:#bf616a;">serialize</span><span>(TreeNode root) {
</span><span>        </span><span style="color:#65737e;">//边界判断，如果为空就返回一个字符串&quot;#&quot;
</span><span>        </span><span style="color:#b48ead;">if </span><span>(root == null)
</span><span>            </span><span style="color:#b48ead;">return </span><span>&quot;</span><span style="color:#a3be8c;">#</span><span>&quot;;
</span><span>        </span><span style="color:#65737e;">//创建一个队列
</span><span>        Queue&lt;TreeNode&gt; queue = </span><span style="color:#b48ead;">new </span><span style="color:#bf616a;">LinkedList</span><span>&lt;&gt;();
</span><span>        StringBuilder res = </span><span style="color:#b48ead;">new </span><span style="color:#bf616a;">StringBuilder</span><span>();
</span><span>        </span><span style="color:#65737e;">//把根节点加入到队列中
</span><span>        queue.</span><span style="color:#bf616a;">add</span><span>(root);
</span><span>        </span><span style="color:#b48ead;">while </span><span>(!queue.</span><span style="color:#bf616a;">isEmpty</span><span>()) {
</span><span>            </span><span style="color:#65737e;">//节点出队
</span><span>            TreeNode node = queue.</span><span style="color:#bf616a;">poll</span><span>();
</span><span>            </span><span style="color:#65737e;">//如果节点为空，添加一个字符&quot;#&quot;作为空的节点
</span><span>            </span><span style="color:#b48ead;">if </span><span>(node == null) {
</span><span>                res.</span><span style="color:#bf616a;">append</span><span>(&quot;</span><span style="color:#a3be8c;">#,</span><span>&quot;);
</span><span>                </span><span style="color:#b48ead;">continue</span><span>;
</span><span>            }
</span><span>            </span><span style="color:#65737e;">//如果节点不为空，把当前节点的值加入到字符串中，
</span><span>            </span><span style="color:#65737e;">//注意节点之间都是以逗号&quot;,&quot;分隔的，在下面把字符
</span><span>            </span><span style="color:#65737e;">//串还原二叉树的时候也是以逗号&quot;,&quot;把字符串进行拆分
</span><span>            res.</span><span style="color:#bf616a;">append</span><span>(node.</span><span style="color:#bf616a;">val </span><span>+ &quot;</span><span style="color:#a3be8c;">,</span><span>&quot;);
</span><span>            </span><span style="color:#65737e;">//左子节点加入到队列中（左子节点有可能为空）
</span><span>            queue.</span><span style="color:#bf616a;">add</span><span>(node.</span><span style="color:#bf616a;">left</span><span>);
</span><span>            </span><span style="color:#65737e;">//右子节点加入到队列中（右子节点有可能为空）
</span><span>            queue.</span><span style="color:#bf616a;">add</span><span>(node.</span><span style="color:#bf616a;">right</span><span>);
</span><span>        }
</span><span>        </span><span style="color:#b48ead;">return</span><span> res.</span><span style="color:#bf616a;">toString</span><span>();
</span><span>    }
</span><span>
</span><span>    </span><span style="color:#65737e;">//把字符串还原为二叉树
</span><span>    public TreeNode </span><span style="color:#bf616a;">deserialize</span><span>(String data) {
</span><span>        </span><span style="color:#65737e;">//如果是&quot;#&quot;，就表示一个空的节点
</span><span>        </span><span style="color:#b48ead;">if </span><span>(data == &quot;</span><span style="color:#a3be8c;">#</span><span>&quot;)
</span><span>            </span><span style="color:#b48ead;">return</span><span> null;
</span><span>        Queue&lt;TreeNode&gt; queue = </span><span style="color:#b48ead;">new </span><span style="color:#bf616a;">LinkedList</span><span>&lt;&gt;();
</span><span>        </span><span style="color:#65737e;">//因为上面每个节点之间是以逗号&quot;,&quot;分隔的，所以这里
</span><span>        </span><span style="color:#65737e;">//也要以逗号&quot;,&quot;来进行拆分
</span><span>        String[] values = data.</span><span style="color:#bf616a;">split</span><span>(&quot;</span><span style="color:#a3be8c;">,</span><span>&quot;);
</span><span>        </span><span style="color:#65737e;">//上面使用的是BFS，所以第一个值就是根节点的值，这里创建根节点
</span><span>        TreeNode root = </span><span style="color:#b48ead;">new </span><span style="color:#bf616a;">TreeNode</span><span>(Integer.</span><span style="color:#bf616a;">parseInt</span><span>(values[</span><span style="color:#d08770;">0</span><span>]));
</span><span>        queue.</span><span style="color:#bf616a;">add</span><span>(root);
</span><span>        </span><span style="color:#b48ead;">for </span><span>(</span><span style="color:#b48ead;">int</span><span> i = </span><span style="color:#d08770;">1</span><span>; i &lt; values.</span><span style="color:#bf616a;">length</span><span>; i++) {
</span><span>            </span><span style="color:#65737e;">//队列中节点出栈
</span><span>            TreeNode parent = queue.</span><span style="color:#bf616a;">poll</span><span>();
</span><span>            </span><span style="color:#65737e;">//因为在BFS中左右子节点是成对出现的，所以这里挨着的两个值一个是
</span><span>            </span><span style="color:#65737e;">//左子节点的值一个是右子节点的值，当前值如果是&quot;#&quot;就表示这个子节点
</span><span>            </span><span style="color:#65737e;">//是空的，如果不是&quot;#&quot;就表示不是空的
</span><span>            </span><span style="color:#b48ead;">if </span><span>(!&quot;</span><span style="color:#a3be8c;">#</span><span>&quot;.</span><span style="color:#bf616a;">equals</span><span>(values[i])) {
</span><span>                TreeNode left = </span><span style="color:#b48ead;">new </span><span style="color:#bf616a;">TreeNode</span><span>(Integer.</span><span style="color:#bf616a;">parseInt</span><span>(values[i]));
</span><span>                parent.</span><span style="color:#bf616a;">left </span><span>= left;
</span><span>                queue.</span><span style="color:#bf616a;">add</span><span>(left);
</span><span>            }
</span><span>            </span><span style="color:#65737e;">//上面如果不为空就是左子节点的值，这里是右子节点的值，注意这里有个i++，
</span><span>            </span><span style="color:#b48ead;">if </span><span>(!&quot;</span><span style="color:#a3be8c;">#</span><span>&quot;.</span><span style="color:#bf616a;">equals</span><span>(values[++i])) {
</span><span>                TreeNode right = </span><span style="color:#b48ead;">new </span><span style="color:#bf616a;">TreeNode</span><span>(Integer.</span><span style="color:#bf616a;">parseInt</span><span>(values[i]));
</span><span>                parent.</span><span style="color:#bf616a;">right </span><span>= right;
</span><span>                queue.</span><span style="color:#bf616a;">add</span><span>(right);
</span><span>            }
</span><span>        }
</span><span>        </span><span style="color:#b48ead;">return</span><span> root;
</span><span>    }
</span><span>}
</span></code></pre>
<h4 id="dfs">DFS</h4>
<pre data-lang="c++" style="background-color:#2b303b;color:#c0c5ce;" class="language-c++ "><code class="language-c++" data-lang="c++"><span style="color:#b48ead;">class </span><span style="color:#ebcb8b;">Codec </span><span style="color:#eff1f5;">{
</span><span style="color:#eff1f5;">
</span><span style="color:#eff1f5;">    </span><span style="color:#65737e;">//把树转化为字符串（使用DFS遍历，也是前序遍历，顺序是：根节点→左子树→右子树）
</span><span style="color:#eff1f5;">    public String </span><span style="color:#bf616a;">serialize</span><span style="color:#eff1f5;">(TreeNode root) {
</span><span style="color:#eff1f5;">        </span><span style="color:#65737e;">//边界判断，如果为空就返回一个字符串&quot;#&quot;
</span><span style="color:#eff1f5;">        </span><span style="color:#b48ead;">if </span><span style="color:#eff1f5;">(root </span><span>==</span><span style="color:#eff1f5;"> null)
</span><span style="color:#eff1f5;">            </span><span style="color:#b48ead;">return </span><span>&quot;</span><span style="color:#a3be8c;">#</span><span>&quot;</span><span style="color:#eff1f5;">;
</span><span style="color:#eff1f5;">        </span><span style="color:#b48ead;">return</span><span style="color:#eff1f5;"> root.</span><span style="color:#bf616a;">val </span><span>+ &quot;</span><span style="color:#a3be8c;">,</span><span>&quot; + </span><span style="color:#bf616a;">serialize</span><span style="color:#eff1f5;">(root.</span><span style="color:#bf616a;">left</span><span style="color:#eff1f5;">) </span><span>+ &quot;</span><span style="color:#a3be8c;">,</span><span>&quot; + </span><span style="color:#bf616a;">serialize</span><span style="color:#eff1f5;">(root.</span><span style="color:#bf616a;">right</span><span style="color:#eff1f5;">);
</span><span style="color:#eff1f5;">    }
</span><span style="color:#eff1f5;">
</span><span style="color:#eff1f5;">    </span><span style="color:#65737e;">//把字符串还原为二叉树
</span><span style="color:#eff1f5;">    public TreeNode </span><span style="color:#bf616a;">deserialize</span><span style="color:#eff1f5;">(String data) {
</span><span style="color:#eff1f5;">        </span><span style="color:#65737e;">//把字符串data以逗号&quot;,&quot;拆分，拆分之后存储到队列中
</span><span style="color:#eff1f5;">        Queue&lt;String&gt; queue </span><span>= </span><span style="color:#b48ead;">new </span><span style="color:#bf616a;">LinkedList</span><span style="color:#eff1f5;">&lt;&gt;(Arrays.</span><span style="color:#bf616a;">asList</span><span style="color:#eff1f5;">(data.</span><span style="color:#bf616a;">split</span><span style="color:#eff1f5;">(</span><span>&quot;</span><span style="color:#a3be8c;">,</span><span>&quot;</span><span style="color:#eff1f5;">)));
</span><span style="color:#eff1f5;">        </span><span style="color:#b48ead;">return </span><span style="color:#bf616a;">helper</span><span style="color:#eff1f5;">(queue);
</span><span style="color:#eff1f5;">    }
</span><span style="color:#eff1f5;">
</span><span style="color:#eff1f5;">    private TreeNode </span><span style="color:#bf616a;">helper</span><span style="color:#eff1f5;">(Queue&lt;String&gt; queue) {
</span><span style="color:#eff1f5;">        </span><span style="color:#65737e;">//出队
</span><span style="color:#eff1f5;">        String </span><span style="color:#bf616a;">sVal </span><span>=</span><span style="color:#eff1f5;"> queue.</span><span style="color:#bf616a;">poll</span><span style="color:#eff1f5;">();
</span><span style="color:#eff1f5;">        </span><span style="color:#65737e;">//如果是&quot;#&quot;表示空节点
</span><span style="color:#eff1f5;">        </span><span style="color:#b48ead;">if </span><span style="color:#eff1f5;">(</span><span>&quot;</span><span style="color:#a3be8c;">#</span><span>&quot;</span><span style="color:#eff1f5;">.</span><span style="color:#bf616a;">equals</span><span style="color:#eff1f5;">(</span><span style="color:#bf616a;">sVal</span><span style="color:#eff1f5;">))
</span><span style="color:#eff1f5;">            </span><span style="color:#b48ead;">return</span><span style="color:#eff1f5;"> null;
</span><span style="color:#eff1f5;">        </span><span style="color:#65737e;">//否则创建当前节点
</span><span style="color:#eff1f5;">        TreeNode root </span><span>= </span><span style="color:#b48ead;">new </span><span style="color:#bf616a;">TreeNode</span><span style="color:#eff1f5;">(Integer.</span><span style="color:#bf616a;">valueOf</span><span style="color:#eff1f5;">(</span><span style="color:#bf616a;">sVal</span><span style="color:#eff1f5;">));
</span><span style="color:#eff1f5;">        </span><span style="color:#65737e;">//分别创建左子树和右子树
</span><span style="color:#eff1f5;">        root.</span><span style="color:#bf616a;">left </span><span>= </span><span style="color:#bf616a;">helper</span><span style="color:#eff1f5;">(queue);
</span><span style="color:#eff1f5;">        root.</span><span style="color:#bf616a;">right </span><span>= </span><span style="color:#bf616a;">helper</span><span style="color:#eff1f5;">(queue);
</span><span style="color:#eff1f5;">        </span><span style="color:#b48ead;">return</span><span style="color:#eff1f5;"> root;
</span><span style="color:#eff1f5;">    }
</span><span style="color:#eff1f5;">}
</span><span>
</span></code></pre>
<h4 id="stringstream">stringstream</h4>
<pre data-lang="c++" style="background-color:#2b303b;color:#c0c5ce;" class="language-c++ "><code class="language-c++" data-lang="c++"><span style="color:#b48ead;">class </span><span style="color:#ebcb8b;">Codec </span><span style="color:#eff1f5;">{
</span><span style="color:#b48ead;">public</span><span style="color:#eff1f5;">:
</span><span style="color:#eff1f5;">
</span><span style="color:#eff1f5;">    </span><span style="color:#65737e;">// Encodes a tree to a single string.
</span><span style="color:#eff1f5;">    string </span><span style="color:#8fa1b3;">serialize</span><span style="color:#eff1f5;">(TreeNode</span><span>* </span><span style="color:#bf616a;">root</span><span style="color:#eff1f5;">) {
</span><span style="color:#eff1f5;">        </span><span style="color:#b48ead;">if</span><span style="color:#eff1f5;">(root </span><span>== </span><span style="color:#d08770;">nullptr</span><span style="color:#eff1f5;">)
</span><span style="color:#eff1f5;">            </span><span style="color:#b48ead;">return </span><span>&quot;</span><span style="color:#a3be8c;">#</span><span>&quot;</span><span style="color:#eff1f5;">;
</span><span style="color:#eff1f5;">
</span><span style="color:#eff1f5;">        </span><span style="color:#b48ead;">return </span><span style="color:#bf616a;">to_string</span><span style="color:#eff1f5;">(root-&gt;</span><span style="color:#bf616a;">val</span><span style="color:#eff1f5;">) </span><span>+ &#39; &#39; + </span><span style="color:#bf616a;">serialize</span><span style="color:#eff1f5;">(root-&gt;</span><span style="color:#bf616a;">left</span><span style="color:#eff1f5;">) </span><span>+ &#39; &#39; + </span><span style="color:#bf616a;">serialize</span><span style="color:#eff1f5;">(root-&gt;</span><span style="color:#bf616a;">right</span><span style="color:#eff1f5;">);
</span><span style="color:#eff1f5;">    }
</span><span style="color:#eff1f5;">
</span><span style="color:#eff1f5;">    </span><span style="color:#65737e;">// Decodes encoded data to tree.
</span><span style="color:#eff1f5;">    TreeNode</span><span>* </span><span style="color:#8fa1b3;">rebuildTree</span><span style="color:#eff1f5;">(stringstream </span><span>&amp;</span><span style="color:#bf616a;">ss</span><span style="color:#eff1f5;">){
</span><span style="color:#eff1f5;">        string tmp;
</span><span style="color:#eff1f5;">        ss </span><span>&gt;&gt;</span><span style="color:#eff1f5;"> tmp;
</span><span style="color:#eff1f5;">        
</span><span style="color:#eff1f5;">        </span><span style="color:#b48ead;">if</span><span style="color:#eff1f5;">(tmp </span><span>== &quot;</span><span style="color:#a3be8c;">#</span><span>&quot;</span><span style="color:#eff1f5;">)
</span><span style="color:#eff1f5;">            </span><span style="color:#b48ead;">return </span><span style="color:#d08770;">nullptr</span><span style="color:#eff1f5;">;
</span><span style="color:#eff1f5;">
</span><span style="color:#eff1f5;">        TreeNode</span><span>*</span><span style="color:#eff1f5;"> node </span><span>= </span><span style="color:#b48ead;">new </span><span style="color:#bf616a;">TreeNode</span><span style="color:#eff1f5;">(</span><span style="color:#bf616a;">stoi</span><span style="color:#eff1f5;">(tmp));
</span><span style="color:#eff1f5;">        node-&gt;</span><span style="color:#bf616a;">left </span><span>= </span><span style="color:#bf616a;">rebuildTree</span><span style="color:#eff1f5;">(ss);
</span><span style="color:#eff1f5;">        node-&gt;</span><span style="color:#bf616a;">right </span><span>= </span><span style="color:#bf616a;">rebuildTree</span><span style="color:#eff1f5;">(ss);
</span><span style="color:#eff1f5;">
</span><span style="color:#eff1f5;">        </span><span style="color:#b48ead;">return</span><span style="color:#eff1f5;"> node;
</span><span style="color:#eff1f5;">    }
</span><span style="color:#eff1f5;">    
</span><span style="color:#eff1f5;">    TreeNode</span><span>* </span><span style="color:#8fa1b3;">deserialize</span><span style="color:#eff1f5;">(string </span><span style="color:#bf616a;">data</span><span style="color:#eff1f5;">) {
</span><span style="color:#eff1f5;">        stringstream </span><span style="color:#bf616a;">ss</span><span style="color:#eff1f5;">(data);
</span><span style="color:#eff1f5;">        </span><span style="color:#b48ead;">return </span><span style="color:#bf616a;">rebuildTree</span><span style="color:#eff1f5;">(ss);
</span><span style="color:#eff1f5;">    }
</span><span style="color:#eff1f5;">}</span><span>;
</span><span>
</span></code></pre>
<h1 id="shu-zhuang-shu-zu-he-xian-duan-shu"><strong>树状数组</strong>和线段树</h1>
<p>维护区间信息 的数据结构有：前缀和、差分数组、树状数组、线段数</p>
<table><thead><tr><th>数据结构 \ 操作</th><th>单点修改</th><th>区间查询</th></tr></thead><tbody>
<tr><td>前缀和</td><td>O(n)</td><td>O(1)</td></tr>
<tr><td>树状数组</td><td>O(logn)</td><td>O(logn)</td></tr>
<tr><td>线段数</td><td>O(logn)</td><td>O(logn)</td></tr>
</tbody></table>
<p>注意：「线段树」和「树状数组」不能处理输入数组的长度有增加或者减少的情况。</p>
<h2 id="ying-yong-chang-jing">应用场景</h2>
<h2 id=""><img src="https://ffangl.github.io/202104101721/.%5Cimg%5Cchoice.png" alt="" /></h2>
<h2 id="jie-gou">结构</h2>
<p><img src="https://ffangl.github.io/202104101721/.%5Cimg%5Cstructure.PNG" alt="" /></p>
<p><a href="https://dowalle.gitbook.io/algo/algorithm/1-shu-ju-jie-gou/5-shu-zhuang-shu-zu-xian-duan-shu#er-shu-zhuang-shu-zu">树状数组&amp;线段树</a></p>
<h2 id="shu-zhuang-shu-zu-mo-ban">树状数组模板</h2>
<p>n 为原始数组的元素个数</p>
<p>idx 为从 1 开始计，0 号下标不用</p>
<pre data-lang="c++" style="background-color:#2b303b;color:#c0c5ce;" class="language-c++ "><code class="language-c++" data-lang="c++"><span style="color:#b48ead;">class </span><span style="color:#ebcb8b;">FenwickTree </span><span style="color:#eff1f5;">{
</span><span style="color:#b48ead;">public</span><span style="color:#eff1f5;">:
</span><span style="color:#eff1f5;">    </span><span style="color:#b48ead;">int</span><span style="color:#eff1f5;"> size;
</span><span style="color:#eff1f5;">    vector&lt;</span><span style="color:#b48ead;">int</span><span style="color:#eff1f5;">&gt; tree;
</span><span style="color:#eff1f5;">
</span><span style="color:#eff1f5;">    </span><span style="color:#8fa1b3;">FenwickTree</span><span style="color:#eff1f5;">(</span><span style="color:#b48ead;">int </span><span style="color:#bf616a;">n</span><span style="color:#eff1f5;">) {
</span><span style="color:#eff1f5;">        size </span><span>=</span><span style="color:#eff1f5;"> n;
</span><span style="color:#eff1f5;">        tree.</span><span style="color:#bf616a;">resize</span><span style="color:#eff1f5;">(size </span><span>+ </span><span style="color:#d08770;">1</span><span style="color:#eff1f5;">, </span><span style="color:#d08770;">0</span><span style="color:#eff1f5;">);
</span><span style="color:#eff1f5;">    }
</span><span style="color:#eff1f5;">	</span><span style="color:#65737e;">// C[i] 的父亲为 C[i+lowbit(i)]
</span><span style="color:#eff1f5;">    </span><span style="color:#65737e;">// C[i] 由 lowbit(i) 个 A 中元素组成
</span><span style="color:#eff1f5;">    </span><span style="color:#b48ead;">int </span><span style="color:#8fa1b3;">lowbit</span><span style="color:#eff1f5;">(</span><span style="color:#b48ead;">int </span><span style="color:#bf616a;">idx</span><span style="color:#eff1f5;">) {
</span><span style="color:#eff1f5;">        </span><span style="color:#65737e;">// idx 为树状数组下标
</span><span style="color:#eff1f5;">        </span><span style="color:#b48ead;">return</span><span style="color:#eff1f5;"> idx </span><span>&amp; </span><span style="color:#eff1f5;">(</span><span>-</span><span style="color:#eff1f5;">idx);
</span><span style="color:#eff1f5;">    }
</span><span style="color:#eff1f5;">    </span><span style="color:#b48ead;">void </span><span style="color:#8fa1b3;">add</span><span style="color:#eff1f5;">(</span><span style="color:#b48ead;">int </span><span style="color:#bf616a;">idx</span><span style="color:#eff1f5;">, </span><span style="color:#b48ead;">int </span><span style="color:#bf616a;">delta</span><span style="color:#eff1f5;">) {
</span><span style="color:#eff1f5;">        </span><span style="color:#65737e;">// 单点更新，从前往后，idx 为树状数组下标
</span><span style="color:#eff1f5;">        </span><span style="color:#65737e;">// delta 为变化量，如果已知需要变化的值val，传入 val - 原始数组[idx-1]
</span><span style="color:#eff1f5;">        </span><span style="color:#b48ead;">while </span><span style="color:#eff1f5;">(idx </span><span>&lt;</span><span style="color:#eff1f5;"> size </span><span>+ </span><span style="color:#d08770;">1</span><span style="color:#eff1f5;">) {
</span><span style="color:#eff1f5;">            tree[idx] </span><span>+=</span><span style="color:#eff1f5;"> delta;
</span><span style="color:#eff1f5;">            idx </span><span>+= </span><span style="color:#bf616a;">lowbit</span><span style="color:#eff1f5;">(idx);
</span><span style="color:#eff1f5;">        }
</span><span style="color:#eff1f5;">    }
</span><span style="color:#eff1f5;">    </span><span style="color:#b48ead;">int </span><span style="color:#8fa1b3;">query</span><span style="color:#eff1f5;">(</span><span style="color:#b48ead;">int </span><span style="color:#bf616a;">idx</span><span style="color:#eff1f5;">) {
</span><span style="color:#eff1f5;">        </span><span style="color:#65737e;">// 查询前缀和，从后往前，idx 为树状数组下标
</span><span style="color:#eff1f5;">        </span><span style="color:#b48ead;">int</span><span style="color:#eff1f5;"> sum </span><span>= </span><span style="color:#d08770;">0</span><span style="color:#eff1f5;">;
</span><span style="color:#eff1f5;">        </span><span style="color:#b48ead;">while </span><span style="color:#eff1f5;">(idx </span><span>&gt; </span><span style="color:#d08770;">0</span><span style="color:#eff1f5;">) {
</span><span style="color:#eff1f5;">            sum </span><span>+=</span><span style="color:#eff1f5;"> tree[idx];
</span><span style="color:#eff1f5;">            idx </span><span>-= </span><span style="color:#bf616a;">lowbit</span><span style="color:#eff1f5;">(idx);
</span><span style="color:#eff1f5;">        }
</span><span style="color:#eff1f5;">        </span><span style="color:#b48ead;">return</span><span style="color:#eff1f5;"> sum;
</span><span style="color:#eff1f5;">    }
</span><span style="color:#eff1f5;">    </span><span style="color:#b48ead;">int </span><span style="color:#8fa1b3;">sumRange</span><span style="color:#eff1f5;">(</span><span style="color:#b48ead;">int </span><span style="color:#bf616a;">left</span><span style="color:#eff1f5;">, </span><span style="color:#b48ead;">int </span><span style="color:#bf616a;">right</span><span style="color:#eff1f5;">) {
</span><span style="color:#eff1f5;">        </span><span style="color:#65737e;">// left, right 为树状数组下标
</span><span style="color:#eff1f5;">        </span><span style="color:#b48ead;">int</span><span style="color:#eff1f5;"> preLeft </span><span>= </span><span style="color:#bf616a;">query</span><span style="color:#eff1f5;">(left </span><span>- </span><span style="color:#d08770;">1</span><span style="color:#eff1f5;">);
</span><span style="color:#eff1f5;">        </span><span style="color:#b48ead;">int</span><span style="color:#eff1f5;"> preRight </span><span>= </span><span style="color:#bf616a;">query</span><span style="color:#eff1f5;">(right);
</span><span style="color:#eff1f5;">        </span><span style="color:#b48ead;">return</span><span style="color:#eff1f5;"> preRight </span><span>-</span><span style="color:#eff1f5;"> preLeft;
</span><span style="color:#eff1f5;">    }
</span><span style="color:#eff1f5;">}</span><span>;
</span></code></pre>
<h3 id="-1"></h3>
<h2 id="xian-duan-shu-mo-ban">线段树模板</h2>
<pre data-lang="c++" style="background-color:#2b303b;color:#c0c5ce;" class="language-c++ "><code class="language-c++" data-lang="c++"><span style="color:#b48ead;">struct </span><span>Node{
</span><span>    </span><span style="color:#b48ead;">int</span><span> l, r;
</span><span>    </span><span style="color:#b48ead;">int</span><span> sum;
</span><span>};
</span><span>
</span><span style="color:#b48ead;">class </span><span style="color:#ebcb8b;">NumArray </span><span style="color:#eff1f5;">{
</span><span style="color:#b48ead;">private</span><span style="color:#eff1f5;">:
</span><span style="color:#eff1f5;">    vector&lt;Node&gt; tr;
</span><span style="color:#eff1f5;">    vector&lt;</span><span style="color:#b48ead;">int</span><span style="color:#eff1f5;">&gt; nums;
</span><span style="color:#eff1f5;">    </span><span style="color:#b48ead;">int</span><span style="color:#eff1f5;"> n;
</span><span style="color:#b48ead;">public</span><span style="color:#eff1f5;">:
</span><span style="color:#eff1f5;">    </span><span style="color:#8fa1b3;">NumArray</span><span style="color:#eff1f5;">(vector&lt;</span><span style="color:#b48ead;">int</span><span style="color:#eff1f5;">&gt;</span><span>&amp; </span><span style="color:#bf616a;">nums</span><span style="color:#eff1f5;">) 
</span><span style="color:#eff1f5;">    {
</span><span style="color:#eff1f5;">        n </span><span>=</span><span style="color:#eff1f5;"> nums.</span><span style="color:#bf616a;">size</span><span style="color:#eff1f5;">();
</span><span style="color:#eff1f5;">        tr </span><span>= </span><span style="color:#bf616a;">vector</span><span style="color:#eff1f5;">&lt;Node&gt;(n </span><span>* </span><span style="color:#d08770;">4</span><span style="color:#eff1f5;">);
</span><span style="color:#eff1f5;">        </span><span style="color:#bf616a;">this </span><span style="color:#eff1f5;">-&gt; </span><span style="color:#bf616a;">nums </span><span>=</span><span style="color:#eff1f5;"> nums;
</span><span style="color:#eff1f5;">        </span><span style="color:#bf616a;">build</span><span style="color:#eff1f5;">(</span><span style="color:#d08770;">1</span><span style="color:#eff1f5;">, </span><span style="color:#d08770;">1</span><span style="color:#eff1f5;">, n);</span><span style="color:#65737e;">//建立线段树
</span><span style="color:#eff1f5;">    }
</span><span style="color:#eff1f5;">    
</span><span style="color:#eff1f5;">    </span><span style="color:#b48ead;">void </span><span style="color:#8fa1b3;">update</span><span style="color:#eff1f5;">(</span><span style="color:#b48ead;">int </span><span style="color:#bf616a;">index</span><span style="color:#eff1f5;">, </span><span style="color:#b48ead;">int </span><span style="color:#bf616a;">val</span><span style="color:#eff1f5;">) 
</span><span style="color:#eff1f5;">    {
</span><span style="color:#eff1f5;">        </span><span style="color:#bf616a;">modify</span><span style="color:#eff1f5;">(</span><span style="color:#d08770;">1</span><span style="color:#eff1f5;">, index </span><span>+ </span><span style="color:#d08770;">1</span><span style="color:#eff1f5;">, val);
</span><span style="color:#eff1f5;">    }
</span><span style="color:#eff1f5;">    
</span><span style="color:#eff1f5;">    </span><span style="color:#b48ead;">int </span><span style="color:#8fa1b3;">sumRange</span><span style="color:#eff1f5;">(</span><span style="color:#b48ead;">int </span><span style="color:#bf616a;">left</span><span style="color:#eff1f5;">, </span><span style="color:#b48ead;">int </span><span style="color:#bf616a;">right</span><span style="color:#eff1f5;">) 
</span><span style="color:#eff1f5;">    {
</span><span style="color:#eff1f5;">        </span><span style="color:#b48ead;">return </span><span style="color:#bf616a;">query</span><span style="color:#eff1f5;">(</span><span style="color:#d08770;">1</span><span style="color:#eff1f5;">, left </span><span>+ </span><span style="color:#d08770;">1</span><span style="color:#eff1f5;">, right </span><span>+ </span><span style="color:#d08770;">1</span><span style="color:#eff1f5;">).</span><span style="color:#bf616a;">sum</span><span style="color:#eff1f5;">;
</span><span style="color:#eff1f5;">    }
</span><span style="color:#eff1f5;">
</span><span style="color:#eff1f5;">    </span><span style="color:#b48ead;">void </span><span style="color:#8fa1b3;">build</span><span style="color:#eff1f5;">(</span><span style="color:#b48ead;">int </span><span style="color:#bf616a;">u</span><span style="color:#eff1f5;">, </span><span style="color:#b48ead;">int </span><span style="color:#bf616a;">l</span><span style="color:#eff1f5;">, </span><span style="color:#b48ead;">int </span><span style="color:#bf616a;">r</span><span style="color:#eff1f5;">)
</span><span style="color:#eff1f5;">    {
</span><span style="color:#eff1f5;">        </span><span style="color:#b48ead;">if </span><span style="color:#eff1f5;">(l </span><span>==</span><span style="color:#eff1f5;"> r) tr[u] </span><span>= </span><span style="color:#eff1f5;">{l, r, nums[l </span><span>- </span><span style="color:#d08770;">1</span><span style="color:#eff1f5;">]};
</span><span style="color:#eff1f5;">        </span><span style="color:#b48ead;">else
</span><span style="color:#eff1f5;">        {
</span><span style="color:#eff1f5;">            tr[u] </span><span>= </span><span style="color:#eff1f5;">{l, r};
</span><span style="color:#eff1f5;">            </span><span style="color:#b48ead;">int</span><span style="color:#eff1f5;"> mid </span><span>=</span><span style="color:#eff1f5;"> l </span><span>+</span><span style="color:#eff1f5;"> r </span><span>&gt;&gt; </span><span style="color:#d08770;">1</span><span style="color:#eff1f5;">;
</span><span style="color:#eff1f5;">            </span><span style="color:#bf616a;">build</span><span style="color:#eff1f5;">(u </span><span>&lt;&lt; </span><span style="color:#d08770;">1</span><span style="color:#eff1f5;">, l, mid), </span><span style="color:#bf616a;">build</span><span style="color:#eff1f5;">(u </span><span>&lt;&lt; </span><span style="color:#d08770;">1 </span><span>| </span><span style="color:#d08770;">1</span><span style="color:#eff1f5;">, mid </span><span>+ </span><span style="color:#d08770;">1</span><span style="color:#eff1f5;">, r);
</span><span style="color:#eff1f5;">            </span><span style="color:#bf616a;">pushup</span><span style="color:#eff1f5;">(u);
</span><span style="color:#eff1f5;">        }
</span><span style="color:#eff1f5;">    }</span><span style="color:#65737e;">//线段树初始化
</span><span style="color:#eff1f5;">
</span><span style="color:#eff1f5;">    </span><span style="color:#b48ead;">void </span><span style="color:#8fa1b3;">pushup</span><span style="color:#eff1f5;">(Node </span><span>&amp;</span><span style="color:#bf616a;">u</span><span style="color:#eff1f5;">, Node </span><span>&amp;</span><span style="color:#bf616a;">l</span><span style="color:#eff1f5;">, Node </span><span>&amp;</span><span style="color:#bf616a;">r</span><span style="color:#eff1f5;">)
</span><span style="color:#eff1f5;">    {
</span><span style="color:#eff1f5;">        u.</span><span style="color:#bf616a;">sum </span><span>=</span><span style="color:#eff1f5;"> l.</span><span style="color:#bf616a;">sum </span><span>+</span><span style="color:#eff1f5;"> r.</span><span style="color:#bf616a;">sum</span><span style="color:#eff1f5;">;
</span><span style="color:#eff1f5;">    }</span><span style="color:#65737e;">//向上调整
</span><span style="color:#eff1f5;">
</span><span style="color:#eff1f5;">    </span><span style="color:#b48ead;">void </span><span style="color:#8fa1b3;">pushup</span><span style="color:#eff1f5;">(</span><span style="color:#b48ead;">int </span><span style="color:#bf616a;">u</span><span style="color:#eff1f5;">)
</span><span style="color:#eff1f5;">    {
</span><span style="color:#eff1f5;">        </span><span style="color:#bf616a;">pushup</span><span style="color:#eff1f5;">(tr[u], tr[u </span><span>&lt;&lt; </span><span style="color:#d08770;">1</span><span style="color:#eff1f5;">], tr[u </span><span>&lt;&lt; </span><span style="color:#d08770;">1 </span><span>| </span><span style="color:#d08770;">1</span><span style="color:#eff1f5;">]);
</span><span style="color:#eff1f5;">    }</span><span style="color:#65737e;">//向上调整
</span><span style="color:#eff1f5;">
</span><span style="color:#eff1f5;">    </span><span style="color:#b48ead;">void </span><span style="color:#8fa1b3;">modify</span><span style="color:#eff1f5;">(</span><span style="color:#b48ead;">int </span><span style="color:#bf616a;">u</span><span style="color:#eff1f5;">, </span><span style="color:#b48ead;">int </span><span style="color:#bf616a;">x</span><span style="color:#eff1f5;">, </span><span style="color:#b48ead;">int </span><span style="color:#bf616a;">val</span><span style="color:#eff1f5;">)
</span><span style="color:#eff1f5;">    {
</span><span style="color:#eff1f5;">        </span><span style="color:#b48ead;">if </span><span style="color:#eff1f5;">(tr[u].</span><span style="color:#bf616a;">l </span><span>==</span><span style="color:#eff1f5;"> x </span><span>&amp;&amp;</span><span style="color:#eff1f5;"> tr[u].</span><span style="color:#bf616a;">r </span><span>==</span><span style="color:#eff1f5;"> x) tr[u] </span><span>= </span><span style="color:#eff1f5;">{x, x, val};
</span><span style="color:#eff1f5;">        </span><span style="color:#b48ead;">else
</span><span style="color:#eff1f5;">        {
</span><span style="color:#eff1f5;">            </span><span style="color:#b48ead;">int</span><span style="color:#eff1f5;"> mid </span><span>=</span><span style="color:#eff1f5;"> tr[u].</span><span style="color:#bf616a;">l </span><span>+</span><span style="color:#eff1f5;"> tr[u].</span><span style="color:#bf616a;">r </span><span>&gt;&gt; </span><span style="color:#d08770;">1</span><span style="color:#eff1f5;">;
</span><span style="color:#eff1f5;">            </span><span style="color:#b48ead;">if </span><span style="color:#eff1f5;">(x </span><span>&lt;=</span><span style="color:#eff1f5;"> mid) </span><span style="color:#bf616a;">modify</span><span style="color:#eff1f5;">(u </span><span>&lt;&lt; </span><span style="color:#d08770;">1</span><span style="color:#eff1f5;">, x, val);</span><span style="color:#65737e;">//左边更新
</span><span style="color:#eff1f5;">            </span><span style="color:#b48ead;">else </span><span style="color:#bf616a;">modify</span><span style="color:#eff1f5;">(u </span><span>&lt;&lt; </span><span style="color:#d08770;">1 </span><span>| </span><span style="color:#d08770;">1</span><span style="color:#eff1f5;">, x, val);</span><span style="color:#65737e;">//右边更新
</span><span style="color:#eff1f5;">            </span><span style="color:#bf616a;">pushup</span><span style="color:#eff1f5;">(u);</span><span style="color:#65737e;">//向上更新父节点
</span><span style="color:#eff1f5;">        }
</span><span style="color:#eff1f5;">    }
</span><span style="color:#eff1f5;">
</span><span style="color:#eff1f5;">    Node </span><span style="color:#8fa1b3;">query</span><span style="color:#eff1f5;">(</span><span style="color:#b48ead;">int </span><span style="color:#bf616a;">u</span><span style="color:#eff1f5;">, </span><span style="color:#b48ead;">int </span><span style="color:#bf616a;">l</span><span style="color:#eff1f5;">, </span><span style="color:#b48ead;">int </span><span style="color:#bf616a;">r</span><span style="color:#eff1f5;">)
</span><span style="color:#eff1f5;">    {
</span><span style="color:#eff1f5;">        </span><span style="color:#b48ead;">if </span><span style="color:#eff1f5;">(tr[u].</span><span style="color:#bf616a;">l </span><span>&gt;=</span><span style="color:#eff1f5;"> l </span><span>&amp;&amp;</span><span style="color:#eff1f5;"> tr[u].</span><span style="color:#bf616a;">r </span><span>&lt;=</span><span style="color:#eff1f5;"> r) </span><span style="color:#b48ead;">return</span><span style="color:#eff1f5;"> tr[u];</span><span style="color:#65737e;">//返回结点
</span><span style="color:#eff1f5;">        </span><span style="color:#b48ead;">else
</span><span style="color:#eff1f5;">        {
</span><span style="color:#eff1f5;">            </span><span style="color:#b48ead;">int</span><span style="color:#eff1f5;"> mid </span><span>=</span><span style="color:#eff1f5;"> tr[u].</span><span style="color:#bf616a;">l </span><span>+</span><span style="color:#eff1f5;"> tr[u].</span><span style="color:#bf616a;">r </span><span>&gt;&gt; </span><span style="color:#d08770;">1</span><span style="color:#eff1f5;">;
</span><span style="color:#eff1f5;">            </span><span style="color:#b48ead;">if </span><span style="color:#eff1f5;">(r </span><span>&lt;=</span><span style="color:#eff1f5;"> mid) </span><span style="color:#b48ead;">return </span><span style="color:#bf616a;">query</span><span style="color:#eff1f5;">(u </span><span>&lt;&lt; </span><span style="color:#d08770;">1</span><span style="color:#eff1f5;">, l, r);</span><span style="color:#65737e;">//左边查询
</span><span style="color:#eff1f5;">            </span><span style="color:#b48ead;">else if </span><span style="color:#eff1f5;">(l </span><span>&gt;</span><span style="color:#eff1f5;"> mid) </span><span style="color:#b48ead;">return </span><span style="color:#bf616a;">query</span><span style="color:#eff1f5;">(u </span><span>&lt;&lt; </span><span style="color:#d08770;">1 </span><span>| </span><span style="color:#d08770;">1</span><span style="color:#eff1f5;">, l, r);</span><span style="color:#65737e;">//右边查询
</span><span style="color:#eff1f5;">            </span><span style="color:#b48ead;">else
</span><span style="color:#eff1f5;">            {
</span><span style="color:#eff1f5;">                </span><span style="color:#b48ead;">auto</span><span style="color:#eff1f5;"> left </span><span>= </span><span style="color:#bf616a;">query</span><span style="color:#eff1f5;">(u </span><span>&lt;&lt; </span><span style="color:#d08770;">1</span><span style="color:#eff1f5;">, l, r);
</span><span style="color:#eff1f5;">                </span><span style="color:#b48ead;">auto</span><span style="color:#eff1f5;"> right </span><span>= </span><span style="color:#bf616a;">query</span><span style="color:#eff1f5;">(u </span><span>&lt;&lt; </span><span style="color:#d08770;">1 </span><span>| </span><span style="color:#d08770;">1</span><span style="color:#eff1f5;">, l, r);
</span><span style="color:#eff1f5;">                Node res;
</span><span style="color:#eff1f5;">                </span><span style="color:#bf616a;">pushup</span><span style="color:#eff1f5;">(res, left, right);</span><span style="color:#65737e;">//两边查询后返回结点和
</span><span style="color:#eff1f5;">                </span><span style="color:#b48ead;">return</span><span style="color:#eff1f5;"> res;
</span><span style="color:#eff1f5;">            }
</span><span style="color:#eff1f5;">        }
</span><span style="color:#eff1f5;">    }
</span><span style="color:#eff1f5;">
</span><span style="color:#eff1f5;">}</span><span>;
</span></code></pre>
<h1 id="zi-dian-shu">字典树</h1>
<p>Trie 树是一种用于**快速查询「某个字符串/字符前缀」**是否存在的数据结构。</p>
<p>其核心是使用「边」来代表有无字符，使用「点」来记录是否为「单词结尾」以及「其后续字符串的字符有哪些」。</p>
<p><img src="C:%5CUsers%5Cprts%5CDesktop%5Cfolder%5Cmy%5Cblog%5CArCeusJ2000.github.io%5Ccontent%5Cshuati_datastructure_template%5Cimg%5Ctrie.png" alt="" /></p>
<h2 id="trieshu-you-hua-dfs">Trie树优化DFS</h2>
<p><code>if (node-&gt;son[nidx] != nullptr)</code> 可做到提前剪枝，大幅度优化</p>
<pre data-lang="c++" style="background-color:#2b303b;color:#c0c5ce;" class="language-c++ "><code class="language-c++" data-lang="c++"><span style="color:#b48ead;">void </span><span style="color:#8fa1b3;">dfs</span><span>(</span><span style="color:#b48ead;">int </span><span style="color:#bf616a;">row</span><span>, </span><span style="color:#b48ead;">int </span><span style="color:#bf616a;">col</span><span>, Trie* </span><span style="color:#bf616a;">node</span><span>) {
</span><span>    </span><span style="color:#b48ead;">if </span><span>(node-&gt;</span><span style="color:#bf616a;">str </span><span>!= &quot;&quot;) {
</span><span>        ans_set.</span><span style="color:#bf616a;">insert</span><span>(node-&gt;</span><span style="color:#bf616a;">str</span><span>);
</span><span>    }
</span><span>    </span><span style="color:#b48ead;">for </span><span>(pair&lt;</span><span style="color:#b48ead;">int</span><span>, </span><span style="color:#b48ead;">int</span><span>&gt; dir : direction) {
</span><span>        </span><span style="color:#b48ead;">int</span><span> nr = row + dir.</span><span style="color:#bf616a;">first</span><span>;
</span><span>        </span><span style="color:#b48ead;">int</span><span> nc = col + dir.</span><span style="color:#bf616a;">second</span><span>;
</span><span>        </span><span style="color:#b48ead;">if </span><span>(</span><span style="color:#d08770;">0 </span><span>&lt;= nr &amp;&amp; nr &lt; rows &amp;&amp; </span><span style="color:#d08770;">0 </span><span>&lt;= nc &amp;&amp; nc &lt; cols) {
</span><span>            </span><span style="color:#b48ead;">if </span><span>(!visited[nr][nc]) {
</span><span>                </span><span style="color:#b48ead;">int</span><span> nidx = board[nr][nc] - &#39;</span><span style="color:#a3be8c;">a</span><span>&#39;;
</span><span>                </span><span style="color:#b48ead;">if </span><span>(node-&gt;</span><span style="color:#bf616a;">son</span><span>[nidx] != </span><span style="color:#d08770;">nullptr</span><span>) {
</span><span>                    visited[nr][nc] = </span><span style="color:#d08770;">true</span><span>;
</span><span>                    </span><span style="color:#bf616a;">dfs</span><span>(nr, nc, node-&gt;</span><span style="color:#bf616a;">son</span><span>[nidx]);
</span><span>                    visited[nr][nc] = </span><span style="color:#d08770;">false</span><span>;
</span><span>                }
</span><span>            }
</span><span>        }
</span><span>    }
</span><span>}
</span></code></pre>
<h2 id="mo-ban">模板</h2>
<h3 id="trienode-shi-xian">TrieNode 实现</h3>
<p>随着数据的不断插入，根据需要不断创建 TrieNode 节点。</p>
<p>时间复杂度：Trie 树的每次调用时间复杂度取决于入参字符串的长度。复杂度为 O(Len)。</p>
<p>空间复杂度：结点数量为 n，字符集大小为 k。复杂度为 O(nk)。</p>
<pre data-lang="c++" style="background-color:#2b303b;color:#c0c5ce;" class="language-c++ "><code class="language-c++" data-lang="c++"><span style="color:#b48ead;">class </span><span style="color:#ebcb8b;">Trie </span><span style="color:#eff1f5;">{
</span><span style="color:#b48ead;">public</span><span style="color:#eff1f5;">:
</span><span style="color:#eff1f5;">    Trie</span><span>*</span><span style="color:#eff1f5;"> son[</span><span style="color:#d08770;">26</span><span style="color:#eff1f5;">];  </span><span style="color:#65737e;">// 存放当前字符之后的字符
</span><span style="color:#eff1f5;">    </span><span style="color:#b48ead;">bool</span><span style="color:#eff1f5;"> isWord;
</span><span style="color:#eff1f5;">    string str;
</span><span style="color:#eff1f5;">  
</span><span style="color:#eff1f5;">    </span><span style="color:#8fa1b3;">Trie</span><span style="color:#eff1f5;">() {
</span><span style="color:#eff1f5;">        </span><span style="color:#b48ead;">for </span><span style="color:#eff1f5;">(</span><span style="color:#b48ead;">int</span><span style="color:#eff1f5;"> i </span><span>= </span><span style="color:#d08770;">0</span><span style="color:#eff1f5;">; i </span><span>&lt; </span><span style="color:#d08770;">26</span><span style="color:#eff1f5;">; i</span><span>++</span><span style="color:#eff1f5;">) son[i] </span><span>= </span><span style="color:#d08770;">nullptr</span><span style="color:#eff1f5;">;
</span><span style="color:#eff1f5;">        isWord </span><span>= </span><span style="color:#d08770;">false</span><span style="color:#eff1f5;">;
</span><span style="color:#eff1f5;">        str </span><span>= &quot;&quot;</span><span style="color:#eff1f5;">;
</span><span style="color:#eff1f5;">    }
</span><span style="color:#eff1f5;">    </span><span style="color:#8fa1b3;">~Trie</span><span style="color:#eff1f5;">() {
</span><span style="color:#eff1f5;">        </span><span style="color:#b48ead;">for </span><span style="color:#eff1f5;">(</span><span style="color:#b48ead;">int</span><span style="color:#eff1f5;"> i </span><span>= </span><span style="color:#d08770;">0</span><span style="color:#eff1f5;">; i </span><span>&lt; </span><span style="color:#d08770;">26</span><span style="color:#eff1f5;">; i</span><span>++</span><span style="color:#eff1f5;">) {
</span><span style="color:#eff1f5;">            </span><span style="color:#b48ead;">if </span><span style="color:#eff1f5;">(son[i] </span><span>!= </span><span style="color:#d08770;">nullptr</span><span style="color:#eff1f5;">) </span><span style="color:#b48ead;">delete</span><span style="color:#eff1f5;"> son[i];
</span><span style="color:#eff1f5;">        }
</span><span style="color:#eff1f5;">    }
</span><span style="color:#eff1f5;">
</span><span style="color:#eff1f5;">    </span><span style="color:#b48ead;">void </span><span style="color:#8fa1b3;">insert</span><span style="color:#eff1f5;">(string </span><span style="color:#bf616a;">word</span><span style="color:#eff1f5;">) {
</span><span style="color:#eff1f5;">        Trie</span><span>*</span><span style="color:#eff1f5;"> root </span><span>= </span><span style="color:#bf616a;">this</span><span style="color:#eff1f5;">;     </span><span style="color:#65737e;">// 从头节点开始查
</span><span style="color:#eff1f5;">        </span><span style="color:#b48ead;">for </span><span style="color:#eff1f5;">(</span><span style="color:#b48ead;">char</span><span style="color:#eff1f5;"> c </span><span>:</span><span style="color:#eff1f5;"> word) {  </span><span style="color:#65737e;">// 类似链表的遍历
</span><span style="color:#eff1f5;">            </span><span style="color:#b48ead;">int</span><span style="color:#eff1f5;"> cur </span><span>=</span><span style="color:#eff1f5;"> c </span><span>- &#39;</span><span style="color:#a3be8c;">a</span><span>&#39;</span><span style="color:#eff1f5;">;
</span><span style="color:#eff1f5;">            </span><span style="color:#b48ead;">if </span><span style="color:#eff1f5;">(root-&gt;</span><span style="color:#bf616a;">son</span><span style="color:#eff1f5;">[cur] </span><span>== </span><span style="color:#d08770;">nullptr</span><span style="color:#eff1f5;">) root-&gt;</span><span style="color:#bf616a;">son</span><span style="color:#eff1f5;">[cur] </span><span>= </span><span style="color:#b48ead;">new </span><span style="color:#bf616a;">Trie</span><span style="color:#eff1f5;">();
</span><span style="color:#eff1f5;">            root </span><span>=</span><span style="color:#eff1f5;"> root-&gt;</span><span style="color:#bf616a;">son</span><span style="color:#eff1f5;">[cur];
</span><span style="color:#eff1f5;">        }
</span><span style="color:#eff1f5;">        root-&gt;</span><span style="color:#bf616a;">isWord </span><span>= </span><span style="color:#d08770;">true</span><span style="color:#eff1f5;">;  </span><span style="color:#65737e;">// 在单词的结尾节点标记一下 是单词
</span><span style="color:#eff1f5;">        root-&gt;</span><span style="color:#bf616a;">str </span><span>=</span><span style="color:#eff1f5;"> word;     </span><span style="color:#65737e;">// 结尾直接记录单词
</span><span style="color:#eff1f5;">    }
</span><span style="color:#eff1f5;">
</span><span style="color:#eff1f5;">    </span><span style="color:#b48ead;">bool </span><span style="color:#8fa1b3;">search</span><span style="color:#eff1f5;">(string </span><span style="color:#bf616a;">word</span><span style="color:#eff1f5;">) {
</span><span style="color:#eff1f5;">        Trie</span><span>*</span><span style="color:#eff1f5;"> root </span><span>= </span><span style="color:#bf616a;">this</span><span style="color:#eff1f5;">;  </span><span style="color:#65737e;">// 从头节点开始查
</span><span style="color:#eff1f5;">        </span><span style="color:#b48ead;">for </span><span style="color:#eff1f5;">(</span><span style="color:#b48ead;">char</span><span style="color:#eff1f5;"> c </span><span>:</span><span style="color:#eff1f5;"> word) {
</span><span style="color:#eff1f5;">            </span><span style="color:#b48ead;">int</span><span style="color:#eff1f5;"> cur </span><span>=</span><span style="color:#eff1f5;"> c </span><span>- &#39;</span><span style="color:#a3be8c;">a</span><span>&#39;</span><span style="color:#eff1f5;">;
</span><span style="color:#eff1f5;">            </span><span style="color:#b48ead;">if </span><span style="color:#eff1f5;">(root-&gt;</span><span style="color:#bf616a;">son</span><span style="color:#eff1f5;">[cur] </span><span>== </span><span style="color:#d08770;">nullptr</span><span style="color:#eff1f5;">) </span><span style="color:#b48ead;">return </span><span style="color:#d08770;">false</span><span style="color:#eff1f5;">;  </span><span style="color:#65737e;">// word还没遍历完，就找不到了
</span><span style="color:#eff1f5;">            root </span><span>=</span><span style="color:#eff1f5;"> root-&gt;</span><span style="color:#bf616a;">son</span><span style="color:#eff1f5;">[cur];
</span><span style="color:#eff1f5;">        }
</span><span style="color:#eff1f5;">        </span><span style="color:#b48ead;">return</span><span style="color:#eff1f5;"> root-&gt;</span><span style="color:#bf616a;">isWord</span><span style="color:#eff1f5;">;  </span><span style="color:#65737e;">// 遍历到word结尾的节点，是否是之前存在的单词
</span><span style="color:#eff1f5;">    }
</span><span style="color:#eff1f5;">
</span><span style="color:#eff1f5;">    </span><span style="color:#b48ead;">bool </span><span style="color:#8fa1b3;">startsWith</span><span style="color:#eff1f5;">(string </span><span style="color:#bf616a;">prefix</span><span style="color:#eff1f5;">) {
</span><span style="color:#eff1f5;">        Trie</span><span>*</span><span style="color:#eff1f5;"> root </span><span>= </span><span style="color:#bf616a;">this</span><span style="color:#eff1f5;">;
</span><span style="color:#eff1f5;">        </span><span style="color:#b48ead;">for </span><span style="color:#eff1f5;">(</span><span style="color:#b48ead;">char</span><span style="color:#eff1f5;"> c </span><span>:</span><span style="color:#eff1f5;"> prefix) {
</span><span style="color:#eff1f5;">            </span><span style="color:#b48ead;">int</span><span style="color:#eff1f5;"> cur </span><span>=</span><span style="color:#eff1f5;"> c </span><span>- &#39;</span><span style="color:#a3be8c;">a</span><span>&#39;</span><span style="color:#eff1f5;">;
</span><span style="color:#eff1f5;">            </span><span style="color:#b48ead;">if </span><span style="color:#eff1f5;">(root-&gt;</span><span style="color:#bf616a;">son</span><span style="color:#eff1f5;">[cur] </span><span>== </span><span style="color:#d08770;">nullptr</span><span style="color:#eff1f5;">) </span><span style="color:#b48ead;">return </span><span style="color:#d08770;">false</span><span style="color:#eff1f5;">;  </span><span style="color:#65737e;">// prefix还没遍历完，就找不到了
</span><span style="color:#eff1f5;">            root </span><span>=</span><span style="color:#eff1f5;"> root-&gt;</span><span style="color:#bf616a;">son</span><span style="color:#eff1f5;">[cur];
</span><span style="color:#eff1f5;">        }
</span><span style="color:#eff1f5;">        </span><span style="color:#b48ead;">return </span><span style="color:#d08770;">true</span><span style="color:#eff1f5;">;  </span><span style="color:#65737e;">// prefix正常遍历完，就返回true
</span><span style="color:#eff1f5;">    }
</span><span style="color:#eff1f5;">}</span><span>;
</span></code></pre>

    </div>

    
    

    <div class="post-footer">
        
            
                <div class="post-tags">
                    
                        <a href="https://ffangl.github.io/tags/cram/">#Cram</a>
                    
                </div>
            
            

        

    </div>

    
    
</article>


                </div>
            </main>

            
            
        </div>

      
          <script type="text/javascript" src="https://ffangl.github.io/even.js" ></script>
      
    </body>

</html>
